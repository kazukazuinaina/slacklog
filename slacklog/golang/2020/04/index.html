---
# vim:set ts=2 sts=2 sw=2 et:
layout: slacklog
title: vim-jp.slack.com log - #golang - 2020年04月
---
<div>
<h2><a href='{{ post.url }}'>{{ page.title }}</a></h2>

<p>参加方法、各チャンネルの概要等は以下を参照して下さい。<br>
<a href='/docs/chat.html'>vim-jpのチャットルームについて</a></p>

{% raw %}
<pre>vikke 1585753354.097200: `receiver.MethodByName("Method1").Call([reflect.ValueOf(1), reflect.ValueOf("aa")])` でも無さげ。syntax error。文法違うのか?</pre>
<pre>vikke 1585754047.097700: `receiver.MethodByName("Method1").Call({reflect.ValueOf(1), reflect.ValueOf("aa")})`も違う。</pre>
<pre>vikke 1585754078.098300: ValueOfがValue返えすので、基本的な考えかたは間違ってない?</pre>
<pre>ゴリラ 1585754201.098700: すいません
こちら、ご存知の方いますか？
<https://twitter.com/gorilla0513/status/1245369097489010692?s=20></pre>
<pre>ゴリラ 1585754241.099200: あ、パスを間違えただけだった…ｗ</pre>
<pre>ゴリラ 1585754246.099500: 失礼しました</pre>
<pre>mattn 1585754745.099700: ```[]reflect.Value{reflect.ValueOf(1), reflect.ValueOf("aa")}```</pre>
<pre>vikke 1585755597.100000: ```package main

import (
	"log"
	"reflect"
)

type MyStruct struct {
}

func (ms *MyStruct) method1(i int, s string) {
	log.Printf("foobar")
}
func main() {
	ms := &amp;MyStruct{}
	receiver := reflect.ValueOf(ms)
	log.Println("before")
	ret := receiver.MethodByName("Method1").Call([]reflect.Value{reflect.ValueOf(1), reflect.ValueOf("aa")})
	log.Println("after %V", ret)
}```
で、
```[master]$ ./main
2020/04/02 00:38:46 before
panic: reflect: call of reflect.Value.Call on zero Value

goroutine 1 [running]:
reflect.flag.mustBe(...)
        /usr/lib/go/src/reflect/value.go:208
reflect.Value.Call(0x0, 0x0, 0x0, 0xc000053f48, 0x2, 0x2, 0x0, 0x0, 0x4e94c0)
        /usr/lib/go/src/reflect/value.go:319 +0x16d
main.main()
        /home/vikke/go/src/github.com/reflection/main.go:18 +0x2aa```
なエラーが出ます。</pre>
<pre>vikke 1585755643.100500: Go, 難しいアルネ</pre>
<pre>vikke 1585755662.100900: ってか、rubyに毒されすぎてたよ。わたし。</pre>
<pre>mattn 1585755715.101300: お昼と同じ間違いしてますよ。</pre>
<pre>mattn 1585755720.101500: method1 が小文字。</pre>
<pre>vikke 1585755830.101700: 死にたい。</pre>
<pre>vikke 1585755947.102000: 通りました。本当に死にたい。</pre>
<pre>mattn 1585756247.102200: YATTA &gt; 通りました</pre>
<pre>johejo 1585770667.103800: <https://golang.org/pkg/net/http/#Server.Shutdown>
ちょっと気になるんですが、このexampleのShutdownってListendAndServeよりも先に呼ばれることがあり得るような気がするんですが、特に気にしなくて良いのでしょうか。</pre>
<pre>tennashi 1585781556.106800: 先に呼ばれたとしても、ListenAndServe は ErrServerClosed を返して即 return するだけなので問題なさそうに思います</pre>
<pre>ゴリラ 1585786261.107600: <http://go.shibu.jp/effective_go.html|http://go.shibu.jp/effective_go.html></pre>
<pre>ゴリラ 1585786267.107900: 久々読んでみたけど</pre>
<pre>ゴリラ 1585786295.108700: newってみんな使うかな</pre>
<pre>ゴリラ 1585786304.109000: ぼくは最近使わなくなったけど</pre>
<pre>ゴリラ 1585786333.109700: &amp;gorilla{}
ってやることが多い</pre>
<pre>0Δ 1585786406.110100: channel作成する時はいつもnew使ってますねー</pre>
<pre>mattn 1585786464.110300: もしかして：「make」</pre>
<pre>0Δ 1585786504.110700: あ、makeだったか (いつもコピペなのがバレる)</pre>
<pre>ゴリラ 1585786570.111400: みんなのnewを使う場面を知りたい</pre>
<pre>eihigh 1585787142.113300: ~型つきでnilを得たいとき…だけですかね~</pre>
<pre>eihigh 1585787148.113600: あ、うそ</pre>
<pre>mattn 1585787149.113700: 場面というか new じゃないとできない物があるので。</pre>
<pre>mattn 1585787168.114200: ```v := new(int)
*v = 1```</pre>
<pre>mattn 1585787229.114800: それ以外について(例: struct)は違いはないですが、リテラルの方は linter で警告できるチャンスがあります。</pre>
<pre>eihigh 1585787336.115400: <https://github.com/google/wire/blob/65ae46b7eaa146e99673e290251ea26f28139362/internal/wire/testdata/FieldsOfImportedStruct/main/wire.go#L31-L35>
"ポインタ型を" newするっていう珍しいケース。自分が知る限りだとこれくらいかな</pre>
<pre>mattn 1585787397.116400: AWS のライブラリだと平気で `*string` をフィールドに持ったりするんで new 無いと死んでしまう。</pre>
<pre>ゴリラ 1585787535.117100: なるほど</pre>
<pre>itchyny 1585787749.117400: google/go-githubとかもそうなんすよね…</pre>
<pre>mattn 1585787790.118100: Java やってた人が Go のライブラリ作るとなりがちという偏見を持っています。</pre>
<pre>itchyny 1585787798.118300: <https://pkg.go.dev/github.com/google/go-github/v30/github?tab=doc#Repository></pre>
<pre>itchyny 1585787822.118600: mapもptrでもっとるな…</pre>
<pre>eihigh 1585787836.118900: go-githubつらいと思ってたけど間違ってなかった。</pre>
<pre>mattn 1585787904.119300: ```Permissions         *map[string]bool `json:"permissions,omitempty"````
これは意味あるのw</pre>
<pre>itchyny 1585787917.119600: ww</pre>
<pre>mattn 1585787952.120700: string や int は nil 判定できないから分からんでもないけど map は nil 判定できるし、単に開発者がポインタで揃ってないと気持ち悪いからって理由でやってる様にしか見えない。</pre>
<pre>itchyny 1585787960.120900: ポインタに統一しておきたかった、などと供述しており</pre>
<pre>johejo 1585788683.123600: mapやsliceなんてそのままでポインタみたいなのものなのになあ
ポインタのポインタはポインタ.... 意味不明...</pre>
<pre>dohq 1585789009.125400: aws-sdk、ほんとポインタだらけでたまに直接デリファレンスしてんぁーってなる…</pre>
<pre>kuu 1585789051.125900: ポインタのポインタを見ると頭がバグる</pre>
<pre>kuu 1585789087.126600: そんなに難しい概念でもないと思うんだけども</pre>
<pre>0Δ 1585789127.127400: ポインタのポインタを何の抵抗もなく受け入れてしまえるのは何故だろうか……
いやパフォーマンスは悪いだろうけど</pre>
<pre>vikke 1585790930.128800: リフレクション楽しいですけど難しい。</pre>
<pre>mattn 1585790986.129500: ちなみに遊びでならいいんですが、昨日の話の様に Go で reflect 使うのかなり特異な要件なので、使わないで済むなら使わない方がいいかもです。</pre>
<pre>vikke 1585791332.130600: そうですね。KoRoNさんも言ってたし。</pre>
<pre>koron 1585791409.131300: まじでGo初心者がreflect使うのはやめたほうが良い。</pre>
<pre>koron 1585791431.131800: 正しく動かすには馬鹿みたいにコードが長くなってGoの旨味なにもなくなるから</pre>
<pre>kuu 1585791946.133300: Javaで必要に迫られてリフレクション使ったことあるけど反吐が出るような思いでコード書いてたな</pre>
<pre>kuu 1585791949.133500: あれは地獄</pre>
<pre>koron 1585791982.134500: 名前の文字列を間違えてメソッド呼び出せなくてってのはあるあるですよねw</pre>
<pre>tsuyoshi_cho 1585792024.135800: python-c++バインディングで中身取り出しに使ったくらいだな、最近は。
基本言語の機能を使うだけ(not reflect)で実現できることで設計するのが普通というか普通に設計するとその言語の機能で実現できることになる、はずみたいなくらいには大概の言語は機能が足りてる</pre>
<pre>tsuyoshi_cho 1585792042.136600: 文字列で表れるのSQL味がある</pre>
<pre>koron 1585792042.136700: 名前の部分定数にしときゃ大丈夫だろって思ったら、その定数の値がまちがってたみたいなのもあるあるですね!</pre>
<pre>kuu 1585792052.137000: リフレクションが必要なのって大体ライブラリが悪いんすよ、ほんとに</pre>
<pre>0Δ 1585792206.138300: pythonみたいな動的メソッド定義をしようとreflect使った事があるけど、それやるならmap使ってチェックした法が色々安全だとわかったこのごろ。</pre>
<pre>vikke 1585792527.139200: 以前javaでreflection使って、良い感じになったのに味をしめてる。</pre>
<pre>mattn 1585792534.139400: 昔 junit3 と junit4、どっちでも動かせる様にリフレクションのコード書いたけど、あの時間は本当に無意味だった。</pre>
<pre>tennashi 1585792692.140600: リフレクション多用しないといけないのであれば動的型付け言語使ったほうが幸せになるだろうなぁと思ったりしますね</pre>
<pre>koron 1585792728.141500: ぼくはリフレクションでディスパッチは言語問わず悪いアイデアだと思いますねぇ。</pre>
<pre>koron 1585792789.142100: 仕事でそういうコード見せられたらガチギレする自信あるw</pre>
<pre>thinca 1585792806.142200: duck typing...</pre>
<pre>tsuyoshi_cho 1585792860.142800: 安全制御が低いduck typingはeasy reflection感があるけど...まあ大概は実害はないか</pre>
<pre>tsuyoshi_cho 1585792886.143500: 静的コンパイルされるduck typingはまあ...というところ(好みの問題)</pre>
<pre>kuu 1585792907.144000: 最適化の兼ね合いとかもあって、動的型言語でもその手のコードは禁忌扱いされてたりするイメージ</pre>
<pre>kuu 1585792929.144500: それ以前に人間にやさしくない</pre>
<pre>thinca 1585793066.145600: Vim script と言う言語があって</pre>
<pre>tsuyoshi_cho 1585793195.147700: 変数展開した関数定義したり、execで文字列実行したり(evalもある)、他にも多数w</pre>
<pre>koron 1585793199.147900: こういう条件でディスパッチしてますよ、っていうのがコード構成ではなく言語構造のほうにはみ出てしまうのがアウトだと私は考えてます。やったほうがスマートに見えるんですが、あとあとの読むときを考えると、ね。</pre>
<pre>eihigh 1585793706.148700: 以前読んだPHPのコードは、名前でメソッド呼び出すせいでそこから先のコードが死ぬほど追いづらかった。トラウマ</pre>
<pre>eihigh 1585793731.149100: 代入タイミングと、呼び出す箇所と、呼び出されるコードがてんでバラバラで…</pre>
<pre>mattn 1585796246.149500: reflect が楽しい、というのは(個人的には)わかる。</pre>
<pre>johejo 1585796395.151800: interface{}を受ける関数でsliceでもstringでもbyteでもなんでもこいやってやつを作ってテストを書いて完成するとしてやったり感が結構大きい。
なおバグの温床</pre>
<pre>mattn 1585804626.155000: ふと思ったんだけど、先日の bradfitz の `if err {}` の proposal、typed nil を解決してくれるなら嬉しい奴じゃないです？</pre>
<pre>ゴリラ 1585806111.155400: typed nil はなにかまだ良くわかっていない</pre>
<pre>mattn 1585806166.156300: <https://play.golang.org/p/LXAxSdzP6s-></pre>
<pre>ゴリラ 1585806178.156500: ```var i interface{} = nil```</pre>
<pre>ゴリラ 1585806203.156800: なる</pre>
<pre>ゴリラ 1585806222.157300: ```var x *int = nil```
これ、nilにならないのは、型情報を持っているから？</pre>
<pre>mattn 1585806334.159200: nil にならない、ではなくそれを interface{} に入れて比較してるのが NG って話です。</pre>
<pre>koron 1585806336.159300: 「型情報を持ってない」ではなく「型情報が一致しない」</pre>
<pre>mattn 1585806344.159500: はい、そういうこと。</pre>
<pre>eihigh 1585806384.160100: untyped nil != (*int)nil
ってことです？</pre>
<pre>mattn 1585806392.160300: yep</pre>
<pre>ゴリラ 1585806453.161100: まだ理解できていない</pre>
<pre>ゴリラ 1585806456.161300: ふむ…</pre>
<pre>mattn 1585806500.162200: 「俺(interface{})には俺なりの美学(nil)があるし、お前(*int)にはお前なりの美学(nil)がある、それだけの話だ」</pre>
<pre>ゴリラ 1585806508.162500: そもそも `nil`ってなんだ…</pre>
<pre>mattn 1585806561.163400: nil はなんにでもなれるわけではない。</pre>
<pre>kuu 1585806563.163500: 値が無効であることを示す値と認識していたけど、違う？</pre>
<pre> 1585806570.163600: </pre>
<pre>mattn 1585806580.164000: いや、なれない。</pre>
<pre>ゴリラ 1585806582.164200: <https://text.baldanders.info/golang/nil-is-nil/></pre>
<pre>ゴリラ 1585806636.164700: ```実際にはこれは「型がない」ことを示している。 同様に値についても，厳密には nil という値ではなく「値がない」ことを示しているのだ。```</pre>
<pre>ゴリラ 1585806638.164900: なるほど</pre>
<pre>eihigh 1585806685.165900: constもですが、untyped hogehogeって特別扱いされる型があるんですよね〜。</pre>
<pre>ゴリラ 1585806757.166500: んー、難しい</pre>
<pre>mattn 1585806867.166900: untyped は扱うのは楽だけど理解が若干難しくなりますね。</pre>
<pre>mattn 1585806893.167400: Go だと四則演算(特に int64 vs float64)はキャストが必要だけど</pre>
<pre>mattn 1585806903.167800: ```const v = 1
func main() {
	var f float64
	var n int64
	println(n + v)
	println(f + v)
}```
untyped だとこういう事ができる。</pre>
<pre>eihigh 1585807399.169100: リテラル `1` は untyped int だし、リテラル `nil` は untyped nil、
いずれも代入すると型が確定する。
```var i int = 1 // ただのint```</pre>
<pre>eihigh 1585807432.169700: ~なんだけどinterface{}に代入するとuntypedのまま入っちゃう感じ。かな~</pre>
<pre>tsuyoshi_cho 1585807440.170000: 静的で型強めな言語でのブラックホールというところですねえ...</pre>
<pre>koron 1585807447.170200: そのばあい `interface{}` っていう型の nil になるんすよ。</pre>
<pre>eihigh 1585807464.170600: ああそうだ。この場合どう表現するんだ…</pre>
<pre>mattn 1585813089.171200: <https://i101330.hatenablog.com/entry/2018/08/26/004005></pre>
<pre>mattn 1585813111.172000: わかる～って感じの記事。</pre>
<pre>tyru 1585813292.173500: わかりみが深い
考える事が少なくて済んで本当に楽…
try 〜 catch だとどこでキャッチするか考えないといけないし、いつ例外飛ぶか分からないし（C 書いてて安心感があるのはそれ）</pre>
<pre>tsuyoshi_cho 1585813444.175100: まあ手続き的にはそうですね、という感覚はわかる(逆にそれ以外がないことの保障が大変だけど)</pre>
<pre>mattn 1585813445.175200: early return していって関数全体で考えないといけない異常系をどんどん消去法ぽく消していけるので脳が楽になる感じ。</pre>
<pre>mattn 1585813460.175400: <https://twitter.com/mattn_jp/status/1031464214282432512></pre>
<pre>mattn 1585813617.176600: `if err != nil` 面倒！ `throw` が欲しい！って人達より、実は Go やってる人達の方がめんどくさがり屋なのかもね。</pre>
<pre>tyru 1585813706.178100: panic() もそうですけど、大域脱出を許しちゃったらそれこそ台無しなんですよねー…</pre>
<pre>tsuyoshi_cho 1585813711.178200: 記述の文句は、たぶんthrowより言語的な明確さがないことと、スペース区切りな複数単語だからという気がしないでもない
(try/catchと差はそこまでないと思うので...)</pre>
<pre>tyru 1585813782.179200: あ、さっきの記事でミス見つけた… これコンパイルエラーにならんのだっけ…
```// err != nil
if err := db.Get(user); err := nil {```</pre>
<pre>mattn 1585813801.179500: ミスぽいですね。</pre>
<pre>tyru 1585813835.180100: Go はいっそ shadowing を禁止してほしかった（極端）</pre>
<pre>tsuyoshi_cho 1585813863.180700: ミス記述を許しちゃうのは、ちょっとだけnnnみたいな(Cのifで代入、みたいな)</pre>
<pre>tyru 1585814105.181700: まぁでも概ね快適なんですよね。これぐらいなら lint で検知できそうなレベルだし</pre>
<pre>mattn 1585814116.181800: や、ビルドは通らないっす。</pre>
<pre>tyru 1585814190.182600: おっとなるほど。すみません
最近 Go 書いてないのがバレてしまう…</pre>
<pre>tsuyoshi_cho 1585814209.183100: あ、検知できるならfoooってカンジですねw(うるさい)</pre>
<pre>tyru 1585814635.183800: 仕事で Go 書きてえ</pre>
<pre>vikke 1585815997.185900: ```package main

import "log"

type I interface {
	Do(s string)
}

type S struct {
	S string
}

func (sp *S) Do(s string) string {
	return sp.S + s
}

func main() {
	s := S{S: "abc"}
	tmp := s.Do("foobar")
	log.Println(tmp)
}```
これって、`(sp *S) Do(s string) string`ってinterfaceを実装したmethodと言えますか?</pre>
<pre>tennashi 1585816042.186400: 関数のシグネチャが違うので言えないですね</pre>
<pre>vikke 1585816076.187300: ```type I interface {
	Do(s string) string
}```
だと良いのか。</pre>
<pre>tennashi 1585816084.187600: ですです</pre>
<pre>vikke 1585816103.188300: 明示的にimportしないから、良くわからなくなる。</pre>
<pre>vikke 1585816197.189700: javaだと、 `List l = new LinkedList()` みたいに抽象化にInterfaceつかえるけど、Goでの使い方が今一ピンと来てない。</pre>
<pre>koron 1585816278.190500: 重箱の隅ですが `I` っていう名前は慣習的にNGで、この場合なら `Doer` とする。</pre>
<pre>vikke 1585816290.190800: ほー。</pre>
<pre>vikke 1585816338.191600: 行為者、実行者(Doer)</pre>
<pre>kuu 1585816379.192000: 関数に渡す上での使い方はJavaの物とそんなに変わらない気がする</pre>
<pre>vikke 1585816430.192900: 頭の切り替え必要。</pre>
<pre>kuu 1585816520.193500: 必要な物を実装していった結果、インターフェースを満たす、みたいなイメージかな</pre>
<pre>vikke 1585816554.193900: ｴｰ!!!</pre>
<pre>kuu 1585816582.195000: この考えで合ってるのかわからないです</pre>
<pre>tyru 1585816641.196500: 基底である (implements を書く) 必要がないですからね。
ダックタイピング的 (structural typing といった方がいいんだろうけど) にユーザがほしいメソッドだけ切り出してインターフェースを定義するみたいな</pre>
<pre>tyru 1585816801.197600: 提供者側がインターフェースを公開するまでもなくユーザ側で定義すれば、それを満たすどんな struct も受け取れるので</pre>
<pre>tennashi 1585817207.198700: <https://play.golang.org/p/7QMKI6Q3JKL>
これより
<https://play.golang.org/p/pzk7LuyCBn4>
こっちのほうが好まれる感じですね</pre>
<pre>koron 1585817240.199300: マルチファイルのgoplayground、たぶん慣れない人にはわかってもらえない…</pre>
<pre>koron 1585817320.199700: これ入れるとわかりやすくなる。 <https://chrome.google.com/webstore/detail/go-playground-addons/kjhcofplemokahbgknjgabnkidaabnde></pre>
<pre>tyru 1585817638.200700: （複数上げれたんだ…）</pre>
<pre>mattn 1585817658.201200: implements を書かなくてもいいので余計に名前重要。</pre>
<pre>kuu 1585817663.201600: 何気に高機能</pre>
<pre>hrsh7th 1585817858.205800: go の interface はあるライブラリの依存コードを、その利用箇所に置けるのが好きです。</pre>
<pre>hrsh7th 1585817887.206400: 説明が難しいですが。</pre>
<pre>tennashi 1585817906.206700: レイヤードアーキテクチャとかクリーンアーキテクチャを Java のサンプル通り実装しちゃうと提供側にインターフェイス書きまくってしまってあれになりがち...</pre>
<pre>hrsh7th 1585817949.207700: Java だと、モデル的なところで implements 書かなきゃなのでピュアな部分に依存が発生してくる。</pre>
<pre>tyru 1585818003.208000: そこで DI</pre>
<pre>tyru 1585818205.208700: Go だと複雑な仕組みがいらないのがよいですね</pre>
<pre>hrsh7th 1585818258.209400: ファイル単位で見たときに依存コードの位置が適切になるというか…</pre>
<pre>kuu 1585818680.209900: DIは人類には早かった</pre>
<pre>mattn 1585818736.211300: しかしサルでも分かる。 <https://qiita.com/hshimo/items/1136087e1c6e5c5b0d9f></pre>
<pre>kuu 1585818753.211700: `encoding/gob`の存在を知ったのでjsonである必要のない箇所を差し替えたらやりとりされるデータのサイズが半分くらいになって小躍りしてる</pre>
<pre>thinca 1585818821.212200: ゴリラにわかるかどうかが分かれ目</pre>
<pre>kuu 1585818851.213100: つまりゴリラさんが理解できればいいのか（ふつうに:rikai: って言い出しそう）</pre>
<pre>mattn 1585818858.213400: サル：DI わかる
ゴリラ：わかるかも
人間：DI わからない</pre>
<pre>tsuyoshi_cho 1585819027.214600: 言語の仕組みについて繰り返し練習しないと覚えられそうにない...という感覚がある(DIが必要になるタイプの経験があまりない..)</pre>
<pre>kuu 1585819080.215200: 猫でも分かるとか猿でも分かるとか書いてあるシリーズ大体人類には厳しいので知性とは…みたいになる</pre>
<pre>dohq 1585819202.215600: 野生の本能的なアレに左右されるのかもしれん</pre>
<pre>mattn 1585819773.216900: Go の場合、Java みたいな DI ってコスト高くなって見通し悪くなりそう。</pre>
<pre>tyru 1585819935.219000: 正直自分も Scala のこのパターンに触れるまで DI って Spring の動的なやつしか触れた事なかったから実行時にエラー起きるし悪い印象しか持ってなかったけど、
ちゃんと静的に DI の役目を果たせてるじゃん、ってなった覚えがあるなー
<https://qiita.com/pab_tech/items/1c0bdbc8a61949891f1f></pre>
<pre>tyru 1585819979.219700: Scala といい DI といいさすがにオフトピすぎたｗ</pre>
<pre>itchyny 1585820012.220100: Cake 僕も好き</pre>
<pre>tyru 1585820091.221400: ↑のは Cake をよりシンプルにしたやつですね。UsesXXX と MixInXXX を公開して trait/object で extends するだけ</pre>
<pre>thinca 1585820100.221600: 実は DI が何者なのか全くわかっていない</pre>
<pre>mattn 1585820176.222000: Cake パターンって名前知ってたけどこういう意味だったの。
&gt; 「僕のケーキに対する敬意という以外の理由としては、ケーキが（ジャムで分けられた）レイヤーから成り、またそのケーキを切り分けることができるということが挙げられる。レイヤーは内部クラスの入れ子構造を表す。上から順にたどっていく事で底辺のレイヤーに行き着くのが似ていると言えなくもない。また、ケーキの一切れは、プロジェクト内のコンポーネントを表し、いくつかのレイヤーを横断して切ることになる。」</pre>
<pre>tyru 1585820213.222400: Onion といい Cake といい開発者は食べ物に例えがち</pre>
<pre>tyru 1585820242.223000: DI は一番簡単な constructor injection から考えるのが分かりやすいと思う</pre>
<pre>mattn 1585820349.223800: Java は DI をアノテーションで難しくしてしまったので、みんな DI がなんだか分からなくなった。</pre>
<pre>hrsh7th 1585820415.225100: new する箇所を設定ファイル的に切り出す + すべて interface への依存にする =&gt; テストしやすいし、インスタンスも設定で切り替えられる =&gt; 副産物的にコンストラクタでの依存解決も同時に可能になった（すべてのインスタンス生成方法を知ったため）
こういう認識です。</pre>
<pre>tyru 1585820511.226500: 設定ファイルもいらない認識です</pre>
<pre>koron 1585820528.226900: DIかどうかはともかくとして、コンポーネント間の依存が複雑になるとコンポーネントの初期化がオブジェクトの引き渡しで実質スパゲッティになるんですよ。それを切るってのがDIの目的の一つ。</pre>
<pre>hrsh7th 1585820576.228100: 設定ファイル的にというのがニュアンスでした :bow: （無名関数で生成処理を切り出すのも設定ファイル的だ。と解釈してます。）</pre>
<pre>tyru 1585820581.228200: 自分はむしろ Spring とか設定ファイルで管理する方法の利点が正直わかってない</pre>
<pre>tyru 1585820594.228600: なるほどです</pre>
<pre>koron 1585820601.228800: コンパイルせずに振る舞いを変えられる。</pre>
<pre>tyru 1585820633.229000: あーなるほど。運用だけで振る舞いを変えられるということですか</pre>
<pre>koron 1585820663.229500: 運用まで行かなくとも、コンパイルが遅いやつには有利かも?</pre>
<pre>hrsh7th 1585820682.230100: そうか、新しく追加したクラスファイルだけ追加でコンパイルして xml いじったら振る舞いを変えられるというのが利点なのか。Java ほとんど書かないので盲点でした。</pre>
<pre>tyru 1585820730.230300: 正直自分的には動的に注入することによって実行時にエラーが起きる方が怖いと思うのであまり感覚が分からないです。。。</pre>
<pre>tyru 1585820744.230800: でもそういう要求はあるんだろうなというのはわかります</pre>
<pre>mattn 1585820754.231300: DI を Java から知ると設定ファイルのイメージありますよね。</pre>
<pre>koron 1585820761.231500: 僕が仕事で書いて使ってる go用のDIっぽいの。DIとは謳ってないけどw
<https://github.com/koron-go/materialize></pre>
<pre>koron 1585820776.231900: *component's dependency separator*</pre>
<pre>mattn 1585820837.233400: コンストラクタでインタフェース貰う様な注入形式で考えると分かり良いすね。</pre>
<pre>hrsh7th 1585820850.233700: インスタンスの生成処理を切り出したことでシングルトンなオブジェクトを注入もできるか。。。
やっぱりいちばんめんどくなりがちな「インスタンスを生成・管理する箱」ができたから、それによってできることは全部やろうってテクノロジーなきがしますね。（だから言語化しづらい）</pre>
<pre>mattn 1585820915.235500: 抽象化する為に昔からやってた事に DI なんてヘンテコな名前が付いてしまったのが諸悪の根源ぽさある。</pre>
<pre>koron 1585820923.235700: googleのコード生成式のもあったけど、いくつかの理由でダイナミックなほうが良いなってなった。</pre>
<pre>tyru 1585820935.235800: 関係ない話ですけど Java から入ったから最初インスタンス生成のタイミング・インスタンスの生存期間って DI と関係あると思ってました…</pre>
<pre>tyru 1585821032.237600: シングルトンとか絡んでくるとそういうのも考慮しなきゃいけないのはわかる（けど混乱した）</pre>
<pre>eihigh 1585821054.238600: Goはwire
ですね、有名どころ
あんま使う気はしないけど…</pre>
<pre>koron 1585821090.238900: まぁ、Javaのやつはほんとツラいよね。ソースコードが馬鹿みたいに追いにくい。

注入されたのがコード生成されたやつだったりすると絶望しかかる。</pre>
<pre>mattn 1585821098.239300: 使った事ないな。wire って名前からするに Java の Autowired な感じなのかな。</pre>
<pre>koron 1585821139.240000: コンストラクタ用の関数いっぱい書いておいて、あとは自動でそれを呼び出すコードを生成する感じ。</pre>
<pre>vikke 1585821164.240600: 仕事は終わった。これからはreflectionのお時間ぬははははは</pre>
<pre>mattn 1585821172.241000: 関数シグネチャで解決する感じかな？</pre>
<pre>koron 1585821188.241400: そんなイメージ</pre>
<pre>tyru 1585821412.243500: 最初の <@U03C71D7H> さんの疑問に乱暴だけど一番簡単な形で答えると、DI はコンストラクタに中で使うインスタンスを全て渡すのと同じってことです。
これはコンストラクタ注入 (constructor injection) といって立派な DI 手法の一つです</pre>
<pre>johejo 1585821473.245800: wireいいですよ コンストラクタインジェクションの手書きから移行しやすい</pre>
<pre>tyru 1585821474.245900: DI・テストに一家言ある Kuniwak さんの記事とか見るとわかるかも…
<https://twitter.com/orga_chem/status/1037991810868555776></pre>
<pre>mattn 1585821527.247800: インスタンスを作るというコードは、インスタンスを作る為に必要な要素(コンストラクタ引数)が増えがちで、そのたびにそれを生成している個所を弄らないといけなくなる。これが問題。なので外から生成済みの物をもらう。</pre>
<pre>thara 1585821548.248400: DI=DIコンテナと考えちゃうと難しく思えちゃうんですよね</pre>
<pre>thinca 1585821579.249300: 少なくとも意識して使ったこと一度もないのだよな…</pre>
<pre>johejo 1585821593.249900: コード生成方式は何よりリフレクションベースじゃないのでコンパイル時に依存の刺し忘れに気づけるし起動も速い</pre>
<pre>tyru 1585821621.250700: 多分 thinca さんだとテスタブルにするために無意識に使ったことあるかもしれない</pre>
<pre>tyru 1585821647.251500: 仰々しい名前が付いてるけど大したことはない</pre>
<pre>mattn 1585821700.252900: わかり良い例だとロガーかな
&gt; ファイルに出力なのか標準出力に出すのか良く分からないけど、とりあえずロガーを貰ってログを吐きたいコードはある、でもファイル名を引数で貰う様な事はしたくない、俺はロガーを欲しいし、ファイルか標準出力かなんて気にしたくない。</pre>
<pre>kuu 1585821704.253000: リフレクションベースの何がアレってIDEによるリファクタリングがしづらいのが</pre>
<pre>kuu 1585821720.253400: 文字列なので書き換えてくれなくってつらい</pre>
<pre>thinca 1585821735.254000: ロガーわかりやすい</pre>
<pre>tyru 1585821778.255600: ロガーは実際 logback とかでそんな感じで設定ファイルで指定しますね</pre>
<pre>mattn 1585821798.256800: Ruby で1枚岩のコード書くとログ出力をファイル、標準出力、を切り替えるコードが本体になっちゃうんですよね。これだと切り替えたいケースでソースを弄らないといけない。</pre>
<pre>koron 1585821812.257500: 僕のやつ、structポインタでも interface でも要求できる。もちろん登録忘れてたらランタイムにエラーになっちゃうけどw</pre>
<pre>johejo 1585821830.258000: Goだとuberのdigとかfxが結構有名ですかね。どっちもリフレクションベースですが</pre>
<pre>mattn 1585821873.259400: で、ロガーを貰う方法としておおまかに
* コンストラクタ経由で貰う方法
* フィールドで貰う方法(アノテーション付けたりする)
の2種類くらいがあります。</pre>
<pre>koron 1585821899.260200: 僕、後者のやつ嫌で採用しなかった。</pre>
<pre>mattn 1585821922.261100: つまり Java が嫌い、とw</pre>
<pre>johejo 1585821924.261200: ライフサイクルの管理とかいろいろやりたくなるとリフレクションベースのが欲しくなる</pre>
<pre>tyru 1585821953.261700: コンストラクタだとどうしても引数が増えちゃうのが難点なんですよね…</pre>
<pre>johejo 1585822004.263900: AutoWired便利なんですけどね 最初は</pre>
<pre>koron 1585822072.265400: その引数すらDIで調達しちゃうイメージ。</pre>
<pre>thara 1585822142.266900: フィールドインジェクションだと、コンストラクタの引数が増える=そのクラスが依存する先が多い、という設計上の問題を感じづらくなるのでJavaコミュニティでも好まれてないと思います</pre>
<pre>tyru 1585822143.267000: つまりこのどちらでもないってことです？
&gt; * コンストラクタ経由で貰う方法
&gt; * フィールドで貰う方法(アノテーション付けたりする)</pre>
<pre>thara 1585822212.267700: （少なくとも今は…)</pre>
<pre>tyru 1585822255.268400: 時代は変わった…（あるいは私の見ていた Java コミュニティが違っていた…）</pre>
<pre>ゴリラ 1585822280.269200: DI、便利だと思いつつ、どういった場合に使うのがベストなのか、あんまわかっていない</pre>
<pre>koron 1585822287.269500: コンストラクタとしてシンプルな関数を登録しておくんです。

`func() (*T, error)` みたいなね。

そうすると *T か *T が満たす interface を要求したときにこの関数が1度だけ呼び出されるようになってるんです。

で、この関数からDIを呼び出して必要な引数をパッケージした値を要求できる。</pre>
<pre>ゴリラ 1585822302.270300: そもそもDIあんま使わないので、そこらへんわかっていないのか</pre>
<pre>mattn 1585822329.271400: 疎結合を究極的に突き止めていくと、おそらくそれが DI になってます。</pre>
<pre>johejo 1585822352.272300: シングルトンの管理とかテスタビリティを高めるためにわりと自然に使ってると思いますね</pre>
<pre>ゴリラ 1585822358.272500: 疎結合 = DI のイメージしかない</pre>
<pre>ゴリラ 1585822379.272900: 疎結合にする ＝ DIするよ
って解釈しています</pre>
<pre>kuu 1585822413.273300: メッセージパッシングによる疎結合も見たことある</pre>
<pre>koron 1585822438.273900: 正確に言うと、この登録する関数が必要な場所から必要な方法で好きに引数を集めてこれるってことかな…</pre>
<pre>koron 1585822488.275500: rubyとかobjectc?w</pre>
<pre>tyru 1585822489.275600: あーなるほど。
`map[string]func()(*T, error)` みたいなテーブルに登録して by name で呼び出すってことです？

ただそれだと正直フィールドで貰う方法とやってることは変わらないような…？
と思ったけど、明示的に↑のコンストラクタを呼び出すってことですかね？</pre>
<pre>koron 1585822518.276800: いやいや名前じゃなくて型で呼び出すんですよ。</pre>
<pre>johejo 1585822527.277300: DIは単に疎結合というよりは交換可能性をうまく高めておくてことだと思ってます</pre>
<pre>koron 1585822536.277500: <https://github.com/koron-go/materialize/#gettings-started></pre>
<pre>koron 1585822544.277900: ↑の例見ていただけると。</pre>
<pre>tyru 1585822556.278400: あ、そうでした。string じゃなかった</pre>
<pre>mattn 1585822607.280200: &gt; 俺はロガーが欲しい。ロガーを作る処理を本体に書きたくないし、ロガーをどこかで生成して俺のコードに渡すようなコードも書きたくない。俺のコードのインスタンスが死んだらロガーは一緒に消えて欲しいが、もっかい俺のコードのインスタンスが生成された時にさっきのが欲しいか、もう一度作りなおしたのが欲しいかは、のちのち決める。
わがまま言いたい放題やな。</pre>
<pre>koron 1585822668.280400: フィールドでやるやつだとマッピングの振る舞いが暗黙的になっちゃうんですが、この方法だと明示的にどこから取ってくるってのをコードで書くことになるんです。

複数の値をいっぺんに取ってきて1つでも取れなかったらエラー、みたいなのを書きやすくしてます。</pre>
<pre>mattn 1585822700.281000: wire は Build で依存関係作ってコマンドで wrapper 吐く感じか。</pre>
<pre>koron 1585822796.281100: 実は

`func(mx *materialize.Context) (*T, error)`

っていう関数も登録できてこの mx を通じていい感じに必須で要求したり、無くてもよいよ～ってのを書けるんです。</pre>
<pre>koron 1585822869.283600: 交換可能性がテスト用途だけならオーバーキルだと思ってて、またそれ以外で実際に入れ替えることが僕の経歴上にはなかったよ…</pre>
<pre>johejo 1585822957.286000: コード生成方式のwireは型で判別するでコンストラクタにプリミティブ型が渡せないからいちいちaliasをはったりしないといけないところがちょっと面倒</pre>
<pre>mattn 1585822986.286600: そうなんよねー。DI で抽象化したコード何度か書いたけど、テスト以外で実際にリポジトリを入れ替えた事ってまぁ無いんだよなw Mock くらい？</pre>
<pre>koron 1585823004.287100: えmockてテスト用途以外で?</pre>
<pre>mattn 1585823013.287600: や、テストで</pre>
<pre>tyru 1585823013.287700: なるほどなるほど。明示的にやるのはいいですね。
フィールド + アノテーションで暗黙的にやっちゃうと、アノテーションつけ忘れただけでぬるぽったりするので。</pre>
<pre>mattn 1585823082.289800: 綺麗になる、テストが楽、がメリットなんだけどそれやる為にだいぶ苦労してる。</pre>
<pre>johejo 1585823145.291100: mongoやめてRDBに戻したときにちょっとだけ助かった。ちょっとだけ</pre>
<pre>koron 1585823294.291800: 11行目の mx.Resolve で循環参照が切れる。</pre>
<pre>koron 1585823372.292000: 12～14行目の文字列は、ヒント情報。interfaceで要求して被った場合に1つに絞り込むために利用する。</pre>
<pre>tyru 1585823468.294500: 一応 Java (というか Spring) の擁護もしておくとｗ
`@Autowired Foo foo;` なフィールドに対して、↑のライブラリと同じように `Foo` を生成するメソッドを指定することはできます。なので「コードで書く」ってのは一応できます。
ヒント情報で渡したり、あと `@Scope("prototype")` で注入した親インスタンスの生存期間に合わせて破棄されるとかも指定できます。</pre>
<pre>johejo 1585823473.294700: Pythonとかだとモンキーパッチでコンストラクタ自体を書き換えてモックを挿入できたりするのでわりとどうとでもなるけどGoはそうもいかないので悩みどころですね</pre>
<pre>tyru 1585823510.294900: まぁ単純に KoRoN さんの要件ではそこまで複雑なものは必要ではなかっただけで、「Java でもできる」ってことは重要じゃないんだろうなというのは理解してます。
（逆に too fat なんだろうなと）</pre>
<pre>koron 1585823552.295200: そうそう。Javaでできることをやりたいんじゃなくて、Goに合った形にしたかったのね。</pre>
<pre>tyru 1585823677.296600: Go だと割と自作してフィットする形にするのが最適解なケースは多い感ありますね。
ただそれで DI コンテナ作っちゃうのは腕力ありすぎですがｗ</pre>
<pre>thara 1585823683.296900: &gt; テスト用途だけならオーバーキル
DIコンテナが出てきた時代はAOPとセットだった気がするので、AOPしなければ利点はだいぶ減ってしまう気がしますね</pre>
<pre>koron 1585823939.297000: いやいやコレが結構シンプルにできてんですよw</pre>
<pre>koron 1585824078.298800: そういやAOPも、実際何が起こっているのかわかりにくくなっただけで、僕はあんま恩恵を受けられなかったんだよな…</pre>
<pre>koron 1585824144.299800: 書くよりも読む(動作を追う)ことが多いからなのかもだけど。</pre>
<pre>tyru 1585824252.301000: ロギング以外に AOP 使ってるの見たことない…
その癖 AspectJ とかクラスファイル書き換えてまで実現してるし、そこまでして何がやりたいのか全然分からなかった…</pre>
<pre>thara 1585824480.303400: 自分がAOPの価値を感じたのは、ロギングとトランザクション境界を外部から設定できる（または呼び出し元によって動的に変える）ことぐらいですね
今なら高階関数とか別の言語機構で同じようなことが実現できるので、あまり採用するモチベは湧かないですね</pre>
<pre>tyru 1585824616.304800: なるほど。トランザクション境界 (`@Transactional` ?) も AOP で実現してたのか。
本当そうなんですよねー &gt;今なら〜</pre>
<pre>mattn 1585824814.307500: ウェブフレームワークのミドルウェアなんかはいい例かも。</pre>
<pre>tyru 1585824846.307900: あぁーなるほど…</pre>
<pre>tyru 1585824919.308500: node の express とか継続っぽいことしてたな (引数の next を呼び出させる)</pre>
<pre>tyru 1585824967.309200: (無限に脱線する性格なのでちゃんと Go の話しないと… せっかく <#CGABGC8LA|golang> を求めてきた人がいっぱい join してきてくれたばっかりなのにｗ)</pre>
<pre>vikke 1585825835.311200: 話ぶった切ってすいません。質問です。
<https://github.com/vikke/go_reflection/blob/master/main.go#L10>
のhogeを文字列でもらった場合に、動的にhogeを作るにはどうしたらよいですか? reflectionにnamespaceやpackageに関するマニュアルを見つけられませんでした。</pre>
<pre>hokorobi 1585826346.311500: "golang.toyko #30 - YouTube" <https://www.youtube.com/watch?v=7YGw-UIkcWw></pre>
<pre>ゴリラ 1585826424.311800: なう</pre>
<pre>ゴリラ 1585826497.312700: &gt; のhogeを文字列でもらった場合に、動的にhogeを作るにはどうしたらよいですか? reflectionにnamespaceやpackageに関するマニュアルを見つけられませんでした。
パッケージのDIって感じですか？</pre>
<pre>ゴリラ 1585826512.313200: アイディアが思いつかない…</pre>
<pre>hokorobi 1585826692.313400: 若者が頑張ってると反応してあげたい（おっさん味）</pre>
<pre>vikke 1585826917.315000: 名前空間と構造体名とメソッド名を外から与えて、メソッドを起動出来ないかなと。
<https://golang.org/pkg/reflect/>
みてるんだけど、それっぽいのにゃい。</pre>
<pre>hrsh7th 1585827304.315800: reflect に package を扱うものはなさそうに見えますね。（そうじゃないとバイナリに埋まってないものが参照されうるのでそりゃそうかなとは思いました）</pre>
<pre>mattn 1585829841.316100: できません。</pre>
<pre>mattn 1585829912.317400: 唯一やれる方法があるとすれば、"hoge" を貰った瞬間にパッケージ名 `hoge` のソースを生成して `-buildmode=plugin` でコンパイルして `plugin.Open` で読み込むくらいです。</pre>
<pre>vikke 1585829958.318100: それはトリッキーですね。面白いです。plugin.Openっていうのがあるのですね。</pre>
<pre>mattn 1585829990.318800: ただし unload は出来ません。</pre>
<pre>mattn 1585830007.319100: あと Windows では動きません。</pre>
<pre>eihigh 1585830064.319500: pluginってメンテされてるのだろうか。1.8のイメージで止まってる。</pre>
<pre>mattn 1585830179.319800: メンテはされてると思いますが、機能的には何も足されてないですね。</pre>
<pre>mattn 1585830204.320200: 使ってるプロダクトはありますけどね。gophernotes とか。</pre>
<pre>eihigh 1585830287.320500: deprecatedではないけど維持はされてる感じかな…</pre>
<pre>vikke 1585830965.321300: rubyってエラーがあった場所でreturnしちゃう事多いですけど、Goの作法ってどんな感じですか?</pre>
<pre>mattn 1585831041.321900: 自分で early return します。</pre>
<pre>mattn 1585831054.322200: 例外はありません。</pre>
<pre>vikke 1585831507.322500: early returnで良いんですね。</pre>
<pre>ゴリラ 1585843042.323300: Goで作るインタプリタ、なぜこのデータ構造なのか全然わからん</pre>
<pre>ゴリラ 1585843046.323500: 難しすぎる</pre>
<pre>ゴリラ 1585843101.323700: <https://github.com/skanehira/monkey/blob/master/ast/ast.go#L147-L151></pre>
<pre>ゴリラ 1585843319.324200: 自分の理解力の無さに嘆く</pre>
<pre>ゴリラ 1585843321.324400: 寝よ</pre>
<pre>ゴリラ 1585843621.324600: 理解してきた</pre>
<pre>ゴリラ 1585843623.324800: 寝る</pre>
<pre>ゴリラ 1585844482.325500: <https://ja.m.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)|https://ja.m.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)></pre>
<pre>ゴリラ 1585844539.326200: まず、JSONのパーサを作るところからやってみようかな</pre>
<pre>ゴリラ 1585844557.326900: そしたら、インタプリタのパーサーも理解できる気がしてきた</pre>
<pre>mattn 1585844592.327300: このデータ構造は InfixExpression しか枝になってないですね。</pre>
<pre>ゴリラ 1585846060.329000: そうすね
prefixはオペレーターとleftしかないすね</pre>
<pre>vikke 1585873229.330300: goでtemplate method patternもどきすら書けない。うぉおおおぉおぉぉ</pre>
<pre>eihigh 1585873421.330700: デザパタもGo書くときに邪魔になるものの一つですよねえ。</pre>
<pre>tsuyoshi_cho 1585873488.331200: 言語の構造と方針が違うから、そのままハマるのが少ないってところでしょうかね?</pre>
<pre>tsuyoshi_cho 1585873515.331900: 理念に近いものならそれなりに翻訳できるものはあると思いますが...</pre>
<pre>eihigh 1585873571.333000: いろんな見方はあると思うんですが
・言語が違うからうまくハマらない
・そもそも無理にデザパタは当てはめるものでもない
・いい感じにやればそれに近くなるから特に意識する必要がない
とかかなあと…</pre>
<pre>tsuyoshi_cho 1585873636.334600: ただ、設計理念の共有のための「パターン」でもあるから
&gt;  いい感じにやればそれに近くなるから特に意識する必要がない
は、若干脳筋的で、それもどうかな、という気がしないでもないw</pre>
<pre>eihigh 1585873641.334700: 知っといて損はないと思うんですけどね。それよかGoに入りてはGoに従う方がよりよく書ける印象。</pre>
<pre>eihigh 1585873683.336400: デザパタちゃんと使う開発入ったことないから分からないな…共通言語として持った方が開発しやすそう（想像）。</pre>
<pre>tsuyoshi_cho 1585873684.336500: まあ実インプリメントの時は、パターンは理念で言語イディオムで適切に実装できることが大事かな、はわかる</pre>
<pre>kuu 1585873693.336600: Goにおけるデザインパターンのようなものに従うしかなさそう</pre>
<pre>kuu 1585873764.338700: 一般的(?)なデザインパターンはオブジェクト指向の世界で生まれたものなので、オブジェクト指向とかけ離れたGoにそのまま適用するのは厳しいのかなって</pre>
<pre>tsuyoshi_cho 1585873831.340600: ですねえ</pre>
<pre>kuu 1585873846.341100: 設計理念として知っておくと便利なのには同意</pre>
<pre>eihigh 1585873911.342100: Goの基本的なパターンこそ大事なんだけど、デザパタやらClean Architectureやらの _バズワード_ に惹かれる人が多いのかな（ド偏見）</pre>
<pre>tsuyoshi_cho 1585873988.343100: まあ、「バズワード」と思って(そのつもりじゃなく、流行りに)寄ってくタイプはだめでしょうかね...
理解しようとして学ぶなら、無理な適用はしないとおもいます</pre>
<pre>kuu 1585874070.344600: 例えばVisitorパターンってありますが、filepath.Walkなんてそのものな設計してますし</pre>
<pre>tsuyoshi_cho 1585874108.345300: あれは継承というより、インタフェースの実装がされてればできるから、Goでは適用しやすい?という気はする</pre>
<pre>mattn 1585874111.345400: template method pattern は abstruct のアレをイメージされておられるのかな？</pre>
<pre>mattn 1585874193.345600: ```package main

type Base struct { }

func (b *Base) DoSomething() {
	println("Yes, We Can!")
}

type Derived struct {
	Base
}

func (rd *Derived) Say() {
	println("セイ")
}


func main() {
	var d Derived

	d.Say()
	d.DoSomething()
}```</pre>
<pre>tennashi 1585874620.347900: GoF のデザパタ、何にも考えずに写経したのは役に立った気がしますね
Go の interface の使い方、どう使うと辛くなるのか、みたいなのが逆説的に理解できた気がします</pre>
<pre>mattn 1585874719.348700: Visitor であれば go/ast に Walk する、ままなやつもありますね。</pre>
<pre>ゴリラ 1585874919.348900: GoF、ナニモワカラナイ</pre>
<pre>mattn 1585874948.349100: GoF の利</pre>
<pre>tennashi 1585875050.350300: <https://github.com/mattn/gof></pre>
<pre>tsuyoshi_cho 1585875064.350800: Go、GoFだぁ～(ちがう)</pre>
<pre>mattn 1585875085.351000: GoF、ちょっと古いので現状にはあってない感あります。</pre>
<pre>tsuyoshi_cho 1585875124.352400: 言語機能の少なさをカバーしてる面もあるので、もうちょっと簡素なベース語を作ってもよさそう</pre>
<pre>mattn 1585875133.352800: 古いというか、フレームワークなんかに巻き取られてて今知る必要ないよなー的な物もある。</pre>
<pre>tennashi 1585875162.353700: ただ語彙として知ってないと本読めないときありますよね</pre>
<pre>tsuyoshi_cho 1585875172.354000: まあ、素データ構造とコレクションフレームワークの対比みたいなもんで、知識は必要なんだろうけど、それで会話しなくなった単語、みたいなのはありますね(一部)</pre>
<pre>mattn 1585875369.355400: 継承がいい物じゃないとされてきつつある今だと、いくらか消えそうなやつ(継承に依存したパターン)もありそう。</pre>
<pre>tsuyoshi_cho 1585875433.356300: まあ移譲したものをかかえれば同じ、という気もしないでもないですが...ちょっといいわましが変りますもんね</pre>
<pre>mattn 1585876066.356600: <https://jp.quora.com/%E4%B8%80%E6%99%82%E6%9C%9F%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A8%E3%81%84%E3%81%86%E3%82%82></pre>
<pre>eihigh 1585876119.357000: いいまとめ。</pre>
<pre>mattn 1585876149.357300: さすゆぐい</pre>
<pre>mattn 1585876193.357600: すぐしたに毛の壁氏が...</pre>
<pre>itchyny 1585876600.358100: <https://go-review.googlesource.com/c/go/+/226877/> これ便利なやつでは</pre>
<pre>tsuyoshi_cho 1585877097.358500: ゲリー、音が...(まだつかったことない)</pre>
<pre>mattn 1585877954.359200: デバッグの為にディレクトリを残す仕組みも欲しいな。</pre>
<pre>mattn 1585877985.359800: と思っていたら issues で bradfitz が os.Exit(1) 書いてて vote down されてたw</pre>
<pre>vikke 1585878756.364600: ```package main

import (
	"log"
)

type Receiver interface {
	Do()
}

type MyReceiver struct {
}

func (w Receiver) Do() {
	log.Println("Do")
}

func main() {
	mr := MyReceiver{}
	<http://mr.Do|mr.Do>()
}```
これって `func (w Receiver) Do() {`で  エラーになるんですけど、Interfaceで受けるって事は出来ないんでしょうか?(まー出来ないからエラーになるんだけど)。どうやるのがGoっぽいですか?</pre>
<pre>koron 1585878825.365800: interface にメソッドの実装はできないんすよ。少し前のJavaもそうだったでしょ?</pre>
<pre>koron 1585878845.366100: interfaceを受け取る ~メソッド~ 関数なら書けるはず。</pre>
<pre>tsuyoshi_cho 1585878928.367100: 上でmattnさんがやってるこれ
<https://vim-jp.slack.com/archives/CGABGC8LA/p1585874193345600>
みたいにやるのがいいのかな</pre>
<pre>vikke 1585878949.367400: ちゃんと理解してきます。</pre>
<pre>vikke 1585879053.367900: インターフェースに実装を書くんじゃなくて、レシーバーをインターフェースで指定出来ないかなーと。</pre>
<pre>koron 1585879105.368100: んー意図が伝わらない。</pre>
<pre>koron 1585879143.368300: 何をしたいのかがわからない。</pre>
<pre>koron 1585879179.368500: まず MyReceiver は Do を実装してないので Receiver になってないですよね。そのチェックをコンパイル時にしたいってこと?</pre>
<pre>vikke 1585879219.368700: あー、色々と僕が駄目です。出直してきます。</pre>
<pre>vikke 1585879657.369400: 凄い初歩的な事聞きますが、MyReceiverはDoを実装していないという部分なんですが、 `func ( w Receiver) Do() {` で実装しているつもりなんですが、これでは駄目?</pre>
<pre>koron 1585879696.369900: `func (w *MyReceiver) Do() { ...` としたほうが良いです。</pre>
<pre>vikke 1585879772.370100: そこを、MyReceiverという構造体では無く interfaceにしたいという話です。interfaceにしたいわけでは無くて、やりたい事は、ダックタイプでDo()が呼べればなんでも良いんですけど。</pre>
<pre>koron 1585879778.370300: ポイントは2つで、Receiver → MyReceiverにすることとポインタにすること。

ポインタにするのはメモリ効率とかその辺。I/Fで扱うと非ポインタだとboxingが起こるんじゃなかったかな。</pre>
<pre>koron 1585879810.370500: その言い方だとやっぱ根本的にI/F理解できてない気がしますね。</pre>
<pre>vikke 1585879818.370700: やはり。</pre>
<pre>vikke 1585879824.370900: 出直してきます。</pre>
<pre>koron 1585880222.371800: ちょっとサンプル書いたんでこれ実行したり書き換えたりして遊んでみてください。RunでWeb上で実行できるんで。
<https://play.golang.org/p/RTq46_kWqW4></pre>
<pre>hrsh7th 1585880256.372400: FileLogger/ConsoleLogger とかの例を試しに実装してみる。とかのほうが理解しやすそうですね。</pre>
<pre>koron 1585880330.373600: 普通の log.New に os.Stderr を渡すか os.Create() の戻り値を渡すかで説明できちゃうんですけどね。どっちも io.Writer 渡すわけだから。</pre>
<pre>hrsh7th 1585880484.374900: 自分で書いてみると理解につながるとは思うんですよね。
その場合に Doer で具体的実装は一つだけ、とかを例にしちゃうと理解しづらそうだなあと感じた次第でした。</pre>
<pre>vikke 1585880515.375000: マンモスありがとうございます。</pre>
<pre>vikke 1585883306.376300: Syntax Errorって一番ださいよね。</pre>
<pre>koron 1585883474.376600: まぁしゃーないんじゃない?</pre>
<pre>vikke 1585884637.377300: それも原因がわからないSyntax Errorはださい</pre>
<pre>kuu 1585884782.378800: Syntax Errorからの「コンパイラ壊れてる！！マジ :shit: 」はみんな通った道なのでは[要出典]</pre>
<pre>kuu 1585884841.379800: こういう場合は大体自分が悪い(ごく稀に本当に壊れてることあるけど)</pre>
<pre>vikke 1585885188.380400: いや、完全に自分のせいですよ。コンパイラのせいなんて0.0001%の確立では?</pre>
<pre>raa0121 1585885247.381100: 新しい言語を書き始めてからの数ヶ月とか、逆に Syntax error 祭りでは</pre>
<pre>vikke 1585885352.381600: ``` syntax error: non-declaration statement outside function body```
って、なんね。宣言場所間違っとるとね?</pre>
<pre>tsuyoshi_cho 1585885393.382000: 関数の外に非宣言ステートメントがある...?</pre>
<pre>tennashi 1585885892.382400: hoge := "hoge" を関数の外で書いたとか</pre>
<pre>tennashi 1585886186.382600: // 俺は正しい!! これは vim のバグに違いない!! -&gt; 私が悪うございました...とか無限回やってる...</pre>
<pre>kuu 1585886279.383900: この前やらかした時はバクレポートまで作ってんだよなぁ…提出しなくて本当によかった</pre>
<pre>johejo 1585886702.386000: Rustなんてコンパイラとの戦いが大部分ですね....</pre>
<pre>tsuyoshi_cho 1585886743.386500: ある説明見てたけどRustのコンパイラは丁寧で厳しい教師という感じですねえ</pre>
<pre>thara 1585886792.386900: エラーメッセージがかなり丁寧ですよね。特にライフタイム周り</pre>
<pre>johejo 1585886868.388500: 昔はgccとかjvmのホットスポットコンパイラよくバグってた（らしい</pre>
<pre>tsuyoshi_cho 1585886901.388900: 目立っちゃうから、というのもあるかも &gt; コンパイラ</pre>
<pre>tsuyoshi_cho 1585886939.389300: <https://linux.srad.jp/story/14/07/28/0945215/></pre>
<pre>thinca 1585886984.390000: Ruby の syntax error、tokenizer レベルのエラーがそのままくるのでキビしい</pre>
<pre>mattn 1585887097.390300: `$` とか見えるとウッってなるやつ。</pre>
<pre>mattn 1585888540.390500: <https://github.com/golang/go/commit/dcf0929de6a12103a8fd7097abd6e797188c366d></pre>
<pre>mattn 1585888550.390900: -h が exit(0) する様になった？</pre>
<pre>kuu 1585888589.391100: ぽいですね</pre>
<pre>vikke 1585889467.391600: methodの頭にfuncと書き忘れたという忘れたいミス。</pre>
<pre>mattn 1585895535.392400: はやくこれ進展して欲しい。 <https://github.com/golang/go/issues/35950></pre>
<pre>itchyny 1585895674.392700: <https://github.com/golang/go/issues/36982> が欲しい</pre>
<pre>yy_yank 1585896091.394600: このチャンネルの過去のやりとり眺めてて思った素朴な疑問なんですが
Goのリフレクションの良い使用例というか、リフレクションを使って上手く書いてる良いライブラリみたいなのありますか？</pre>
<pre>yy_yank 1585896142.395400: ユニットテストでreflect.DeepEqual書いてるのぐらいしか見たことがない…</pre>
<pre>tennashi 1585896156.395500: encoding/json とかは使われてますよね</pre>
<pre>tennashi 1585896170.395600: // たしか</pre>
<pre>tsuyoshi_cho 1585896199.396000: structを動的に作るんでしたっけ?</pre>
<pre>tennashi 1585896254.397200: <https://golang.org/src/encoding/json/decode.go></pre>
<pre>koron 1585896260.397700: んーORM系はreflect駆使しないとできないよね。</pre>
<pre>mattn 1585896270.397800: anko という、Go ぽいインタプリタを作ってます。anko から Go のオブジェクトを Go ぽく操作できる様にしてるので vm はフル reflect です。</pre>
<pre>mattn 1585896296.398400: <https://github.com/mattn/anko/></pre>
<pre>koron 1585896300.398900: ちなみに昨日の koron-go/materialize もリフレクションないと成立しない。</pre>
<pre>yy_yank 1585896381.399800: あー、なるほどencoding/json
ORM系も確かにありそうです。
そもそもリフレクションが最終手段感があってそういうところで使われることが多そうですね</pre>
<pre>koron 1585896406.399900: <https://github.com/koron-go/materialize/blob/cf17f2b04e60328eb42f3ba0691fbce5d812c050/materialize.go#L55></pre>
<pre>koron 1585896452.401900: 言葉で言うと「ライブラリ成立時に取り扱う型について何の前提も持ち込めない」場合はreflectに頼むしかないんですよね。</pre>
<pre>itchyny 1585896459.402300: alecthomas/participleとかも</pre>
<pre>koron 1585896464.402500: いやコード生成があるか。</pre>
<pre>tsuyoshi_cho 1585896469.403000: 動的にオブジェクト(goならstruct)生成のORMやらのバインディングはリフレクションの添加というか、その視点にたって動く機能ですもんね..</pre>
<pre>itchyny 1585896491.403500: 任意のstructを受け取っていい感じに値を埋める系</pre>
<pre>mattn 1585896495.403700: struct tag 弄るならいりますね。</pre>
<pre>mattn 1585896506.404000: fillin とかも使ってそう。</pre>
<pre>mattn 1585896532.404500: 使ってなかったw</pre>
<pre>mattn 1585896567.405000: あ、僕が思ってたやつと違った。</pre>
<pre>itchyny 1585896572.405200: 文字列なので…</pre>
<pre>mattn 1585896610.406000: 誰のだったろう。form の validator みたいな奴を見た事あったけど。</pre>
<pre>itchyny 1585896655.406200: jessevdk/go-flagsとかも</pre>
<pre>mattn 1585896675.406400: たぶん Perl の HTML::FillInForm と記憶がグチャになってそう。</pre>
<pre>itchyny 1585896761.407200: リフレクションをうまく使うというよりも、リフレクションせざるを得ないという感じなんですよね</pre>
<pre>itchyny 1585896934.408300: `reflect` `unsafe` は二大要注意パッケージ</pre>
<pre>johejo 1585897104.409200: みんGoにもちょっとreflectionの解説がありますね</pre>
<pre>johejo 1585897266.410200: introduction to black magic in Golang みたいな記事とか本とかないかな</pre>
<pre>mattn 1585897358.410700: anko はおそらく reflect のほとんどの機能使ってます。</pre>
<pre>mattn 1585897401.411400: ```#!anko

var http, ioutil = import("net/http"), import("io/ioutil")

r = http.DefaultClient.Get("<http://golang.org/>")
b, _ = ioutil.ReadAll(r[0].Body)
printf("%s", toString(b))
r[0].Body.Close()```</pre>
<pre>raa0121 1585897405.411800: つまり、anko を読めば reflect マスターになれると</pre>
<pre>mattn 1585897408.412000: これをスクリプトで動かせる様にしてるので。</pre>
<pre>yy_yank 1585897469.412600: おぉ、anko楽しいですね
そしてREADMEの団子がうまそう</pre>
<pre>mattn 1585897483.412900: そんでもって意外と
```#!anko

var http = import("net/http")

http.HandleFunc("/", func(w, r) {
  w.Write(toByteSlice("hello world"))
})
http.ListenAndServe(":8080", nil)```
このウェブサーバが実用できるくらい速い。</pre>
<pre>itchyny 1585897548.413600: サーバーに埋め込むために機能制限とかできるのかな</pre>
<pre>mattn 1585897590.414400: import できるパッケージを絞る事はできます。</pre>
<pre>mattn 1585897620.415100: ガワを生成するコマンドを使えばサードパッケージも import 可。</pre>
<pre>itchyny 1585897628.415300: よさそう</pre>
<pre>mattn 1585897655.416100: 幾らかの業務で使って貰ってるらしいですが、誰もどれで使ってるか教えてくれない。</pre>
<pre>vikke 1585897657.416200: 今僕は雰囲気でGoを書いている。</pre>
<pre>mattn 1585897720.417000: ちなみに anko から色んな物をそぎ落として、式しか書けないやつが kinako</pre>
<pre>mattn 1585897727.417500: <https://github.com/mattn/kinako></pre>
<pre>mattn 1585897753.418600: きなこ餅おいしそう。</pre>
<pre>yy_yank 1585897756.418800: わらびもちうまそう(そこじゃない)</pre>
<pre>johejo 1585897773.419300: Goは雰囲気でも割と書ける（個人の主観です</pre>
<pre>yy_yank 1585897884.420300: ankoはコマンドでscriptをロードで
kinakoはGoコード内で呼び出して引数で式を渡すみたいな感じですかね？</pre>
<pre>mattn 1585898018.420800: kinako はたしか、どれかの gettext ライブラリの一部に使われてたかな。</pre>
<pre>mattn 1585898060.421500: VM ぽい事やるには必須になりますね。</pre>
<pre>mattn 1585898171.422400: <https://github.com/itchyny/gojq/blob/f42ed4671c084d0526f03103e0ce6f13f5915e5f/execute.go></pre>
<pre>mattn 1585898175.422800: 結構使っていた。</pre>
<pre>johejo 1585898194.423200: kinako parserとastとvmがイイ感じに読みやすいコード量で実装されてて勉強にちょうど良さそう :sasumatsu:</pre>
<pre>mattn 1585898247.423700: kinako は読みやすい量かもですね。</pre>
<pre>mattn 1585898278.424000: slim の go 実装も良く似た感じの量。 <https://github.com/mattn/go-slim/></pre>
<pre>mattn 1585898395.424400: <http://github.com/alecthomas/participle|github.com/alecthomas/participle></pre>
<pre>mattn 1585898405.424700: チャラっと VM 書くには便利そう。</pre>
<pre>johejo 1585898459.425200: チャラい</pre>
<pre>itchyny 1585898486.425600: participle使い始めるとgoyaccの使い方忘れちゃうんですよ</pre>
<pre>eihigh 1585898626.426000: participle、いずれがっつりパーサ書くときは使おうと心に決めている。まだその機会はない。</pre>
<pre>ゴリラ 1585899893.428100: gopls、Macで
GO111MODULES on だと プロジェクト内のパッケージに定義ジャンプできない
auto だと 外部ライブラリに定義ジャンプできない
off だと 問題なし
謎すぎる</pre>
<pre>mattn 1585900423.428600: GOPATH 内にいます？それとも外です？</pre>
<pre>ゴリラ 1585900446.428800: 内ですね</pre>
<pre>mattn 1585901058.429600: 一度 $GOPATH/pkg/mod を別名にするかなんかした方がいいかも。</pre>
<pre>mattn 1585901084.430300: あとプロジェクト(カレントディレクトリ)直下にある go.mod が正しいかも確認した方がいいかも。</pre>
<pre>mattn 1585901137.431200: ちなみに特殊な事してないですよね？
* go へのパスがシンボリックリンク
* GOPATH もしくは GOPATH/src/xxx などがシンボリックリンク</pre>
<pre>mattn 1585902115.431800: 余計なのが混じってるなら tidy するなども。</pre>
<pre>dictav 1585902259.432400: retag ちょっと使ってます
<https://github.com/sevlyar/retag></pre>
<pre>koron 1585903102.432800: gopls、ときどきおかしくなるよねw</pre>
<pre>mattn 1585905393.434000: ゴリラさん、ずっと gopls 動いてないのでたぶんゴリラさんの環境側に何かあるんだと思ってます。</pre>
<pre>mattn 1585905440.434800: 同じリポジトリで最新の gopls 動かして差が出たので。</pre>
<pre>ゴリラ 1585906991.435100: &gt; ちなみに特殊な事してないですよね？
&gt; * go へのパスがシンボリックリンク
&gt; * GOPATH もしくは GOPATH/src/xxx などがシンボリックリンク
何もしていないですね</pre>
<pre>ゴリラ 1585907013.435600: &gt; ゴリラさん、ずっと gopls 動いてないのでたぶんゴリラさんの環境側に何かあるんだと思ってます。
Mac2台ともに同じ現象にあっています…</pre>
<pre>ゴリラ 1585907032.436200: Linuxは大丈夫だったけど、なぜかMacだけ…</pre>
<pre>ゴリラ 1585907055.436900: &gt; 余計なのが混じってるなら tidy するなども。
tidy もしました</pre>
<pre>hrsh7th 1585907107.438600: <@UDDCM376D>
A プロジェクトのファイルを開き、A プロジェクト内で定義ジャンプや補完をする… ①
A プロジェクトのファイルを一度開き、次に B プロジェクトのファイルを別バッファで開いて、B の中で定義ジャンプや補完をする… ②

場合によっては現状の vim-lsp は ② のケースはうまく扱えないかもしれません。</pre>
<pre>ゴリラ 1585907108.438800: goplsの更新、pkgのclean、Goの更新、プラグインの更新
色々やりました</pre>
<pre>hrsh7th 1585907116.439000: ① がちゃんと動かないとしたらよくわからないですが。</pre>
<pre>ゴリラ 1585907143.439300: &gt; ① がちゃんと動かないとしたらよくわからないですが。
①が動かないですね…</pre>
<pre>mattn 1585907951.440100: 開いた直後はジャンプ効かないですが、すぐ実行しました？</pre>
<pre>ゴリラ 1585909151.440600: いえ</pre>
<pre>ゴリラ 1585909161.440900: いくら待ってもジャンプできないですね</pre>
<pre>johejo 1585909233.441400: これはminimal再現vimrc案件では</pre>
<pre>ゴリラ 1585909616.442100: ちょっと帰ってミニマムをやってみます</pre>
<pre>daisuzu 1585913344.443000: ログを見てみると良いかもしれません
GO111MODULEで動きが変わるということはvim-lspよりはgoplsの方が怪しそうです</pre>
<pre>vikke 1585914264.444600: 型アサーションでデータが欠落する事ってあります?
```    18: func SendMail(script module.Script, opt interface{}) {
    19:         v, _ := opt.(pb.OrderCancelAtShopParam)
=&gt;  20:         log.Printf("SendMail: %s", v.GetScriptName())
    21:
    22:         impl := module.InOutLoggerImpl{}
    23:         <http://impl.In|impl.In>()
    24:         script.Exec(opt)
    25:         impl.Out()
(dlv) p opt
interface {}(*<http://github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam|github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam>) *{
        Id: 1,
        ScriptName: "OrderCancelAtShop",
        XXX_NoUnkeyedLiteral: struct {} {},
        XXX_unrecognized: []uint8 len: 0, cap: 0, nil,
        XXX_sizecache: 0,}
(dlv) p v
<http://github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam|github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam> {
        Id: 0,
        ScriptName: "",
        XXX_NoUnkeyedLiteral: struct {} {},
        XXX_unrecognized: []uint8 len: 0, cap: 0, nil,
        XXX_sizecache: 0,}```
こんな感じで、型アサーションの前後でIdとScriptNameが欠落してしまってます。</pre>
<pre>itchyny 1585914444.445100: `v, _` となってますが、 `v, ok` として `ok` の値を見てもらえますか</pre>
<pre>itchyny 1585914531.445600: `ok` が `false` なら型アサーションに失敗しています</pre>
<pre>vikke 1585914676.446600: ```=&gt;  20:         log.Printf("ok: %s", ok)
    21:         log.Printf("SendMail: %s", v.GetScriptName())
    22:
    23:         impl := module.InOutLoggerImpl{}
    24:         <http://impl.In|impl.In>()
    25:         script.Exec(opt)
(dlv) p ok
false
(dlv) p v
<http://github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam|github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam> {
        Id: 0,
        ScriptName: "",
        XXX_NoUnkeyedLiteral: struct {} {},
        XXX_unrecognized: []uint8 len: 0, cap: 0, nil,
        XXX_sizecache: 0,}
(```
falseでした。型を思い込んでました。ありがとうございます。</pre>
<pre>itchyny 1585914703.447000: `opt.(*pb.OrderCancelAtShopParam)` ですね、おそらく。</pre>
<pre>vikke 1585914739.447300: 確かに。。。面目無い。</pre>
<pre>vikke 1585914748.447500: ESP力はんぱない。</pre>
<pre>koron 1585920882.447900: 型アサーションしたあとのOKチェックは必須。</pre>
<pre>koron 1585920911.448400: 絶対に型があってると思ってもチェックすべし。</pre>
<pre>johejo 1585924000.449800: terraform-provider-azurermのソースがチェックなし型アサーションだらけでうぇーってなる</pre>
<pre>vikke 1585924793.450400: 循環参照うぇーーーー。これ直すの大変だなー。というポエム。</pre>
<pre>ゴリラ 1585967681.451900: sliceのinsert、頭の良さを感じた
<https://github.com/golang/go/wiki/SliceTricks#insert>

``` a = append(a[:i], append([]T{x}, a[i:]...)...)```</pre>
<pre>mattn 1585968305.452800: なんとなく遅そう。(要検証)</pre>
<pre>mattn 1585968485.454800: 「Go は任意型の追加とか苦手でしょ」の反論の為に書かれてるものが混じってそう。</pre>
<pre>mattn 1585983457.455300: <https://twitter.com/mattn_jp/status/1246331001476804609></pre>
<pre>mattn 1585984408.456000: ちょっと間違っててこそっと直した。</pre>
<pre>itchyny 1585984586.456500: そこまで変わらんかった…
```/private/tmp go test -bench .
goos: darwin
goarch: amd64
pkg: tmp
BenchmarkAppend-16         97662             11558 ns/op
BenchmarkNormal-16        113486             10220 ns/op```</pre>
<pre>mattn 1585984631.456900: なんだろう。Windows なんか違うんかな。</pre>
<pre>mattn 1585984665.457100: あ、StopTimer 入ってない。</pre>
<pre>koron 1585984705.457400: ん～</pre>
<pre>mattn 1585984728.458200: なおし。</pre>
<pre>koron 1585984732.458300: 2つ疑問があって、最初見た時に記事にあったベンチ結果が消えたのと、あとNormalのほうなんでcopyつかわないの?</pre>
<pre>itchyny 1585984734.458400: ```copy(output, input[:n])
copy(output[n:], insert)
copy(output[n+len(insert):], input[n:])```
これはどうだろう</pre>
<pre>mattn 1585984813.458600: そもれ良さそう。</pre>
<pre>mattn 1585984872.458900: ```BenchmarkAppend-8          42700             26185 ns/op
BenchmarkNormal-8          70170             18005 ns/op
BenchmarkCopy-8            90902             15787 ns/op```</pre>
<pre>mattn 1585984992.459100: 更新した。</pre>
<pre>itchyny 1585985089.459400: ```BenchmarkAppend-16         99148             12840 ns/op
BenchmarkNormal-16        120246             10274 ns/op
BenchmarkCopy-16          195975              5688 ns/op```</pre>
<pre>mattn 1585985143.459700: なんの差だろう。</pre>
<pre>mattn 1585985174.460000: 測り直すたびに変わる。</pre>
<pre>mattn 1585985178.460200: ```BenchmarkAppend-8          35395             31836 ns/op
BenchmarkNormal-8          61192             21202 ns/op
BenchmarkCopy-8           100820             14641 ns/op```</pre>
<pre>itchyny 1585985208.460700: いずれにせよ みんな copy 使おう</pre>
<pre>tsuyoshi_cho 1585985216.461000: キャッシュメモリとかが響く?</pre>
<pre>mattn 1585985216.461100: そうね。</pre>
<pre>tsuyoshi_cho 1585985229.461400: まあcopyですよね...</pre>
<pre>mattn 1585985316.462100: copy は気を付けないと突き抜けるケースがあるので少しアレ。</pre>
<pre>mattn 1585985349.462500: len 以上、cap 以下にコピーしうるケース。</pre>
<pre>tsuyoshi_cho 1585985373.463000: unmanageな機能ってところですか</pre>
<pre>mattn 1585985395.463300: コアチームも稀にやってしまう。</pre>
<pre>eihigh 1585985468.464200: insertはループ回してやるかなあ、sliceTrickでも書けるんですけどやっぱ読みづらいし…</pre>
<pre>eihigh 1585985504.464800: unshiftくらいまでならappendでやるけど。</pre>
<pre>mattn 1585985535.465200: 少なくとも cap がデカくなる append のハックは無いすね。</pre>
<pre>tsuyoshi_cho 1585985704.466100: insertが頻発する場合は、array-link-listなやつを作っちゃって、ですかねえ</pre>
<pre>mattn 1585985874.466900: 動的型付け言語触る人達は Go の配列やスライスがメモリブロックだって意識が少し薄いかもしれない。</pre>
<pre>ゴリラ 1585990687.467700: ベンチマークあざます
勉強になりました</pre>
<pre>eihigh 1585991186.469400: &gt; メモリブロックだって意識が少し薄いかも

すごく健康的だ……[][]を見ただけでメモリ配列が気になって夜も眠れなくなるので……</pre>
<pre>mattn 1585991854.471200: C言語やってる人だと配列が2次元にも3次元にも見えるので便利。</pre>
<pre>tsuyoshi_cho 1585991920.471700: 逆に最終的なフラットなメモリ空間を想像して齟齬がでたりしてw</pre>
<pre>ゴリラ 1585993347.472000: &gt; 動的型付け言語触る人達は Go の配列やスライスがメモリブロックだって意識が少し薄いかもしれない。
メモリブロック…？</pre>
<pre>mattn 1586004383.476600: 例えば Ruby だと `a = [1, 2, 3]` ってやったら数値が3つで 8 バイト x 3 = 24 バイト取ってそうに見えるけど、実際は型の情報も持ってるし `a[1] = "foo"` ってやったらオブジェクトもリンクされる。つまりメモリが直列じゃないんですよね。Go だと `[500]byte` は 500 バイトなんですよね。1要素に 1 バイト以上の物は突っ込めない。</pre>
<pre>vikke 1586073712.477500: interfaceと実装は同じpackageじゃないと駄目。覚えた。</pre>
<pre>tennashi 1586074345.478100: そんなことはないですよ
<https://golang.org/pkg/io/#Reader>
<https://golang.org/pkg/bytes/#Buffer.Read></pre>
<pre>vikke 1586074751.478800: あれ? さっき書いてて、同じパッケージにしてねってメッセージが出たんだが。幻?</pre>
<pre>iwata 1586075004.479200: unexportedだったとか？</pre>
<pre>vikke 1586075125.479500: <https://qiita.com/Yarimizu14/items/e93097c4f4cfd5468259> な話?</pre>
<pre>kyoh86 1586088961.481500: Linuxbrewが思うように動かなくて怒りのあまり作ってしまった</pre>
<pre>kyoh86 1586088962.481700: <https://qiita.com/kyoh86/items/f5e007bc004c34b2d314></pre>
<pre>kuu 1586089034.482100: 怒り駆動開発わかる</pre>
<pre>kyoh86 1586089218.482400: 多分同じ時間使えばlinuxbrew動いたんですけどね</pre>
<pre>kyoh86 1586089240.482800: こうしてまた訳のわからんオレオレツールが爆誕するのだ</pre>
<pre>tsuyoshi_cho 1586092289.483100: good</pre>
<pre>tsuyoshi_cho 1586092310.483600: しかしlinuxbrewがうまくいかないと、どうしました?</pre>
<pre>mattn 1586092385.484000: 僕はこういうツールの名前自体を忘れてしまう。</pre>
<pre>kyoh86 1586093408.485000: なんかいい名前がアレば変えようと思ってます笑</pre>
<pre>kyoh86 1586093425.485500: godownloaderとかghgとか取られちゃってるんで、どうすっかなーという気持ち</pre>
<pre>tsuyoshi_cho 1586093528.486100: 5getter (いま5chだから) はあれですね...</pre>
<pre>kyoh86 1586093635.486500: そういや不思議と数字から始めるコマンドって発想がなかったですね…なるほど</pre>
<pre>thinca 1586093715.486700: 2to3</pre>
<pre>kuu 1586093763.487000: 7z</pre>
<pre>kyoh86 1586094259.488100: たしかに</pre>
<pre>kuu 1586094369.488800: babelも昔は数字ネームだったような</pre>
<pre>kyoh86 1586094430.490100: ちなみにlinuxbrewが動かなかったのは、インストールの段階でrubyの何かのエラーが出た瞬間、僕のrubyトラウマ的事情で深堀りを諦めてしまっただけです</pre>
<pre>tsuyoshi_cho 1586094456.490400: 手動インストールしたほうがよかったかもですね</pre>
<pre>tsuyoshi_cho 1586094502.491300: あー、でも今はbashインストーラだから、その後の段階かもしれないですし、ちょっと面倒ですね</pre>
<pre>eihigh 1586094517.491800: Goも昔は数字ネーム。</pre>
<pre>eihigh 1586094572.492400: &gt; 今はbashインストーラ
いったい何nyさんの偉業なんだ…</pre>
<pre>mattn 1586098104.493200: <https://twitter.com/mattn_jp/status/1246801704634306563></pre>
<pre>mattn 1586098128.493600: 何ny さんが欲しいって言ってたやつ。</pre>
<pre>raa0121 1586100820.495100: <https://gobinaries.com/></pre>
<pre>raa0121 1586100852.495800: curl と sh だけあれば動くやつ</pre>
<pre>Hajime Hoshi 1586102586.496700: 最近 go install しないでなるべく go.mod 有効範囲内で go run している</pre>
<pre>kyoh86 1586126000.498300: gobinaries便利そうですよねー。
go向きじゃないツールの案内にはいい</pre>
<pre>mattn 1586126595.001000: tj 氏、昔から有名人なのでまぁ大丈夫と思うけど僕はこういうの「知らない人からお菓子貰っちゃいけません」みたいな自制力が働く。</pre>
<pre>tsuyoshi_cho 1586130111.001800: とはいえ、特にCIなら、都度コンンパイルよりはプリビルドバイナリだよな、というのもなきにしもあらず..</pre>
<pre>johejo 1586135724.005700: パイプでshに流し込むやつ 基本的にいつも中身をチェックしてる。
CI上でもteeとかでstderrなんかにも流すようにしたりset -xとかしたほうがいいのかな。</pre>
<pre>itchyny 1586146288.010400: <#CGZTGR6E6|javascript> でASI (automatic semicolon insertion) が話題になっているけれど、Go言語も実はASIは行われている (JavaScriptと違ってむしろセミコロン省略が推奨される)。<https://golang.org/ref/spec#Blocks> を見ると `StatementList = { Statement ";" } .` となっており、ここに改行がセパレーターとして使えるという記述はない。セミコロン挿入のルールは <https://golang.org/ref/spec#Semicolons> 。このルールが頭に入っていると以下のようなコードがなぜコンパイルできないのかが理解できる (そしてJavaScriptのASIルールとの違いも感じられる)。
```x := "x"
	+ "y"
switch strings.ToUpper(x)
{
	case "XY":
		println(x)
}```</pre>
<pre>tyru 1586148736.011500: gofmt するとこうなった。なるほど
```	x := "x"
	+"y"
	switch strings.ToUpper(x); {
	case "XY":
		println(x)
	}```</pre>
<pre>tyru 1586148777.012100: 基本的に :w 時に gofmt かけるようにしてるので知らなかった</pre>
<pre>johejo 1586161239.015800: retryableなhttp clientでよく使われているのって
- hashicorp/go-retryablehttp
- gojektech/heimdall
とかですかね。
自前で実装してもいいけどエラーハンドリングとbodyのio.Readerのところちょっと工夫しないといけなさそうなで参考になりそうな実装を探してます。</pre>
<pre>dohq 1586163236.016400: <https://github.com/cenkalti/backoff>
もなんかで見た記憶ありますね</pre>
<pre>mattn 1586163744.016700: <https://github.com/shogo82148/go-retry></pre>
<pre>mattn 1586163773.017000: <https://github.com/Songmu/retry></pre>
<pre>mattn 1586163778.017300: クライアントではないけど。</pre>
<pre>mattn 1586164510.017500: もひとつ
<https://github.com/lestrrat-go/backoff></pre>
<pre>tsuyoshi_cho 1586164549.017900: リポジトリでわかるとはいえ、かぶりまくり</pre>
<pre>mattn 1586164655.018400: 現存システムに近い作りになってるでしょうし、少しずつ違うんでしょうな。</pre>
<pre>mattn 1586164714.018600: <https://twitter.com/xatierlikeLee/status/1247069907813937160></pre>
<pre> 1586164729.018900: </pre>
<pre>mattn 1586164731.019300: ぜんぜんかわらない...</pre>
<pre>dohq 1586164744.019500: どういうことなの…</pre>
<pre> 1586164880.019600: ぜんぜんわからない</pre>
<pre>mattn 1586165148.020100: アカウント名、日本語だし聞いてみるのもいいかも。</pre>
<pre> 1586165219.020200: </pre>
<pre>raa0121 1586165229.020900: excite もわからん…</pre>
<pre>mattn 1586165285.021600: これ、deepl の訳とか信じてしまうと下手すると事故るでw</pre>
<pre>raa0121 1586165357.021800: ops → oppai …？</pre>
<pre>mattn 1586165429.022500: 中国語は一度英語に変換してから日本語に変換するとうまく行く、という話を昔聞いた事があるのでやってみました。</pre>
<pre> 1586165432.022700: </pre>
<pre>mattn 1586165437.023100: 中国語なにも分からない</pre>
<pre>mattn 1586165687.023300: 聞いた。</pre>
<pre>itchyny 1586165979.023900: 出來 (chūlái) → 粗乃 (cūnǎi) なのかな？</pre>
<pre>thinca 1586166339.024500: 中国語分かる ~人~ ゴリラに翻訳してもらうとよさそう <@UDDCM376D></pre>
<pre>itchyny 1586166386.025200: (((プロフ見たところ単に好きなだけな気もする)))</pre>
<pre>mattn 1586166463.026900: えっ。質問してしまった。そういう返事が返ってきた時にどう返せばいいの...</pre>
<pre>thinca 1586166497.027400: 日本にもこういう人いるからなぁ。そういう可能性ありそう</pre>
<pre>mattn 1586166548.027700: つらい</pre>
<pre>ゴリラ 1586167132.028700: mattnさん、中国でも神様認定されてるのか</pre>
<pre>johejo 1586169285.029600: お、いろいろ紹介していただいてありがとうございます</pre>
<pre>mattn 1586173975.033900: <https://twitter.com/xatierlikeLee/status/1247125215802322944?s=20|https://twitter.com/xatierlikeLee/status/1247125215802322944?s=20></pre>
<pre>mattn 1586173985.034400: 中国語ぜんぜん分からない。</pre>
<pre>ゴリラ 1586175344.034700: ぼくも全然分からない</pre>
<pre>ゴリラ 1586183927.035000: もっとGoに詳しくなりたい</pre>
<pre>ゴリラ 1586183936.035400: もっとGo書けるようになりたい</pre>
<pre>ゴリラ 1586183948.035900: そんな想いが溢れる深夜23時</pre>
<pre>ゴリラ 1586188848.036700: Pratt、少し仲良くなれた気がした</pre>
<pre>ゴリラ 1586188880.037400: パーサのとこ、理解しつつある</pre>
<pre>ゴリラ 1586188893.037800: 少しだけ成長した気がした</pre>
<pre>mattn 1586213916.038100: :goodpoem:</pre>
<pre>ゴリラ 1586217457.040300: パーサの動き、少しずつわかってきたけど、どうその実装に至ったのか、まだ良くわかっていない</pre>
<pre>ゴリラ 1586217476.040900: そこさえ理解できれば、応用ができるようになるはず</pre>
<pre>ゴリラ 1586217961.041100: <http://logic.cs.tsukuba.ac.jp/ppl2016/slides/visual_parsing.pdf|http://logic.cs.tsukuba.ac.jp/ppl2016/slides/visual_parsing.pdf></pre>
<pre>kuu 1586218210.041400: とてもいい資料だ</pre>
<pre>mattn 1586218974.041600: ね、いい資料。</pre>
<pre>ゴリラ 1586219187.041900: ぼくにはまだ難しい</pre>
<pre>ゴリラ 1586219217.042500: Prattのところな、イメージはできました</pre>
<pre>johejo 1586220308.043400: 大学でこの手の単位ちゃんと取ったはずなのに何も覚えてない....</pre>
<pre>mattn 1586220451.044400: その辺を学ぶの、言語を作るがゴールなのであれば若干遠回りな感じもする。</pre>
<pre>mattn 1586220477.045000: いっそ BNF 学んで感触つかむってのもいいかも。(ここは意見が割れるかも)</pre>
<pre>mattn 1586220742.046200: その辺行けたらたぶん vimlparser にコントリビュートできますね。</pre>
<pre>koron 1586222380.046500: これめちゃくちゃ良い資料だな…</pre>
<pre>koron 1586222415.047100: ただ初学者には図の意味からしてわからんから、解説必須な感じ。</pre>
<pre>ゴリラ 1586222644.048000: &gt; いっそ BNF 学んで感触つかむってのもいいかも。(ここは意見が割れるかも)
BNFはなんとなく読めるくらいですね
それをコードに落とし込むってところが全然まだまだですね…</pre>
<pre>mattn 1586227258.049100: そういえば↑の tj が更改してる Go のバイナリを作ってくれる奴、CPU 依存な奴はどうなるんだろう。</pre>
<pre>itchyny 1586245534.050200: <https://github.com/golang/go/issues/38287> なんだろう？</pre>
<pre>mattn 1586247083.050800: ほえー。go1.13 から go1.14 にそんな変更がみあたらん。</pre>
<pre>mattn 1586247110.051100: overwrite の場合に限った話ぽいけど。</pre>
<pre>mattn 1586248176.051800: ん？ `MoveFileEx(from, to, MOVEFILE_REPLACE_EXISTING)` が RO の時に false 返るんやけど。</pre>
<pre>mattn 1586248205.052200: これもしかして以前は `chmod +w` みたいな事してたんとちゃうか。</pre>
<pre>koron 1586248273.052600: 古いのすぐ見れるけど、どこみればええの?</pre>
<pre>mattn 1586248427.053100: os.Remove の呼び出しから先は見たので ioutil.WriteFile の perm がちゃんと使われていたかどうか、くらいかなぁ。</pre>
<pre>mattn 1586248446.053300: あ、いや。</pre>
<pre>mattn 1586248464.053800: まずは</pre>
<pre>koron 1586248477.054200: まったくおなじだったわ</pre>
<pre>mattn 1586248490.054400: ```package main_test

import (
        "io/ioutil"
        "os"
        "testing"
)

func TestRenameRO(t *testing.T) {
        os.Remove("a")
        os.Remove("b")
        defer os.Remove("a")
        defer os.Remove("b")

        if err := ioutil.WriteFile("a", []byte("some data"), 0644); err != nil { // rw
                t.Fatal(err)
        }
        if err := ioutil.WriteFile("b", []byte("some data"), 0444); err != nil { // ro
                t.Fatal(err)
        }
        if err := os.Rename("a", "b"); err != nil {
                t.Error(err)
        }
}```</pre>
<pre>mattn 1586248499.054700: これ go1.13 で通りますか？</pre>
<pre>mattn 1586248596.055700: ioutil.WriteFile が perm ちゃんと設定できてなかった、みたいな方が濃厚な気もするけど。</pre>
<pre>koron 1586248618.055900: 通るわw</pre>
<pre>mattn 1586248640.056100: まじかー</pre>
<pre>koron 1586248655.056500: でねdefer消すとbだけ残る</pre>
<pre>mattn 1586248661.056800: ほう。</pre>
<pre>koron 1586248669.057000: 1.14にしてやってみるね</pre>
<pre>koron 1586248751.057600: 1.14.1 だと a, b両方残って b はreadonlyっぽい</pre>
<pre>mattn 1586248804.058400: Go まったく使わず C言語で
```touch a b
chmod -w b```
(これは msys2 で)
して
```#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

int
main() {
  printf("%d\n", MoveFileExW(L"a", L"b", MOVEFILE_REPLACE_EXISTING));
  printf("%d\n", GetLastError());
  return 0;
}```
実行したら 0 2 なんす。</pre>
<pre>mattn 1586248820.059000: なので今の Go の動きは書いてある通りに動いてる。</pre>
<pre>koron 1586248837.059400: ふむ。やっぱ 1.13.9 だと、b が書き込み可能で残ってる。</pre>
<pre>koron 1586248855.060000: ioutil.WriteFileのpermがちゃんと動いてなかった説濃厚</pre>
<pre>mattn 1586248856.060100: 書き込み可能な a が b にリネームされたからかと。</pre>
<pre>mattn 1586248874.060400: つまりそういう事ですかね &gt; 濃厚</pre>
<pre>mattn 1586248891.060800: Rename も defer も消したら両方残るんじゃないすかね。</pre>
<pre>mattn 1586248900.061000: でそのファイルモードが見たいす。</pre>
<pre>mattn 1586248906.061300: go1.13 の。</pre>
<pre>koron 1586248920.061600: えっと両方とも書き込み可能で作成されてたわ。</pre>
<pre>koron 1586248925.061800: スクショ要る?</pre>
<pre>mattn 1586248939.062300: あ、やっぱり WriteFile が失敗してたって話か。</pre>
<pre>koron 1586248947.062500: ええ。</pre>
<pre>koron 1586248958.062900: っていうか書き込み不可だと、os.Removeは失敗しますのう。</pre>
<pre>koron 1586249245.063600: あれ? 1.13.9 の syscall/syscall_windows.go の Open が perm 使ってないよ?w</pre>
<pre>koron 1586249282.063900: `h, e := CreateFile(pathp, access, sharemode, sa, createmode, FILE_ATTRIBUTE_NORMAL, 0)` こうなってるw</pre>
<pre> 1586249303.064000: 一方で1.14.1 はこう</pre>
<pre>koron 1586249312.064500: これはワロスw</pre>
<pre>mattn 1586249431.064700: <https://github.com/golang/go/commit/16f0f9c8e1e767d10d483939981e3b2242554c33></pre>
<pre>mattn 1586249435.065100: これっぽい気がする。</pre>
<pre>mattn 1586249488.065300: side effect だなこれ。</pre>
<pre>mattn 1586249554.065600: コミットメッセージに悪かったのが直ったって書いてあるしな。</pre>
<pre>koron 1586249620.065900: それですなw</pre>
<pre>koron 1586249646.066400: 問題があるとすると os.Remove() がREADONLYファイルに失敗することかも。</pre>
<pre>mattn 1586249672.066700: それはそれでなんかあった気がする。</pre>
<pre>mattn 1586249794.067600: あ、あってたわ。</pre>
<pre>mattn 1586249795.067800: <https://github.com/golang/go/issues/26295></pre>
<pre>mattn 1586249820.068400: Windows の DeleteFile って readonly だとエラーになるんですよね。</pre>
<pre>mattn 1586249855.068700: <https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-deletefilea>
&gt; To delete a read-only file, first you must remove the read-only attribute.</pre>
<pre>mattn 1586249866.069000: ひどい仕様です。</pre>
<pre>mattn 1586249914.069900: ディレクトリを一括で消してる最中に別の要因で消せなくなった際に元に戻せないなら 26295 はマージすべきじゃない、みたいな話だったと思う。</pre>
<pre>koron 1586249983.070800: エクスプローラーからだと消せるんだけど…shell32.dllが頑張ってんのか…</pre>
<pre>mattn 1586250098.072400: 現状 Windows でも同じ様にちゃんと RO になる可能性のあるファイルを消すなら os.Chmod で +w してから os.Remove しないといけないって話になってしまう。</pre>
<pre>koron 1586250194.073700: OSの差異だから、os.Removeの仕様としてやってくれると助かるのは助かりますねぇ。</pre>
<pre>mattn 1586250219.074500: そうすね。</pre>
<pre>tsuyoshi_cho 1586250256.075800: ちなみにですが、逆にUnixだとディレクトリのパーミッションチェックとかどうなんでしょう?</pre>
<pre>koron 1586250260.076000: 事前にチェックしてないなら、やってみてエラー見てos.Chmod(+w)ケースかな</pre>
<pre>mattn 1586250621.076200: いややっとるな。</pre>
<pre>mattn 1586250640.076400: <https://github.com/mattn/go/blob/2fbca94db7e14fc1d18162cd203d7afc19b520e8/src/os/file_windows.go#L302></pre>
<pre>mattn 1586250658.076900: これが機能しとらん。(僕のアイコン出てきてビビった時の顔)</pre>
<pre>mattn 1586250687.077200: この条件が ATTRIBUTE_NORMAL でもやらんといかん。</pre>
<pre>k-takata 1586252415.078200: ディレクトリの場合にはREADONLYビットを落としてリトライはしないのかな？</pre>
<pre>mattn 1586252470.078600: ディレクトリの場合は RemoveDirectory 使ってるんですよね。</pre>
<pre>mattn 1586252508.078900: そっちはたしか ro を消せた気が。</pre>
<pre>mattn 1586252579.079500: いや、このコードは中のファイルが ro の可能性あるから「無理だって」話かな。</pre>
<pre>mattn 1586252663.080000: 一応 CL 投げた。</pre>
<pre>mattn 1586252860.080400: 前々関係ないけど「プログラミング言語大全」の献本が飛んでくる事になった。</pre>
<pre>mattn 1586252890.080900: ﾀﾀﾞ読みｻｲｺｰ</pre>
<pre>k-takata 1586253271.081400: RemoveDirectoryもro消せなかったような。</pre>
<pre>k-takata 1586253476.083000: しかし、Unix系はファイル・ディレクトリ自身ではなく、それがあるディレクトリがroだと消せないという動きだから、動作が違ってややこしい。</pre>
<pre>mattn 1586257872.083200: ですね。</pre>
<pre>tsuyoshi_cho 1586262369.084200: ですねえ
そしてもしかして誤解されてるかもですが、「Unix系のファイル削除で、その親のディレクトリのパーミッション不足の時の動作はどうなんだろう」だったんです...とはいえたぶん考慮されてるかな?</pre>
<pre>mattn 1586262466.084900: Windows の場合はどちみちディレクトリじゃなくファイルの権限変えていかないと消せないし、その途中でエラーが発生する可能性もあるので、そうなると元に戻すの大変なんすよね。</pre>
<pre>tsuyoshi_cho 1586262709.085200: たしかに</pre>
{% endraw %}
