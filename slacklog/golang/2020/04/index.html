---
# vim:set ts=2 sts=2 sw=2 et:
layout: slacklog
title: vim-jp.slack.com log - &#35golang - 2020年04月
---
<div>
<h2><a href='{{ post.url }}'>{{ page.title }}</a></h2>

<p>参加方法、各チャンネルの概要等は以下を参照して下さい。<br>
<a href='/docs/chat.html'>vim-jpのチャットルームについて</a></p>

{% raw %}
<pre>vikke 2日 00:02:35: `receiver.MethodByName("Method1").Call([reflect.ValueOf(1), reflect.ValueOf("aa")])` でも無さげ。syntax error。文法違うのか?</pre>
<pre>vikke 2日 00:14:08: `receiver.MethodByName("Method1").Call({reflect.ValueOf(1), reflect.ValueOf("aa")})`も違う。</pre>
<pre>vikke 2日 00:14:39: ValueOfがValue返えすので、基本的な考えかたは間違ってない?</pre>
<pre>ゴリラ 2日 00:16:42: すいません
こちら、ご存知の方いますか？
<https://twitter.com/gorilla0513/status/1245369097489010692?s=20></pre>
<pre>ゴリラ 2日 00:17:22: あ、パスを間違えただけだった…ｗ</pre>
<pre>ゴリラ 2日 00:17:27: 失礼しました</pre>
<pre>mattn 2日 00:25:46: ```[]reflect.Value{reflect.ValueOf(1), reflect.ValueOf("aa")}```</pre>
<pre>vikke 2日 00:39:58: ```package main

import (
	"log"
	"reflect"
)

type MyStruct struct {
}

func (ms *MyStruct) method1(i int, s string) {
	log.Printf("foobar")
}
func main() {
	ms := &amp;MyStruct{}
	receiver := reflect.ValueOf(ms)
	log.Println("before")
	ret := receiver.MethodByName("Method1").Call([]reflect.Value{reflect.ValueOf(1), reflect.ValueOf("aa")})
	log.Println("after %V", ret)
}```
で、
```[master]$ ./main
2020/04/02 00:38:46 before
panic: reflect: call of reflect.Value.Call on zero Value

goroutine 1 [running]:
reflect.flag.mustBe(...)
        /usr/lib/go/src/reflect/value.go:208
reflect.Value.Call(0x0, 0x0, 0x0, 0xc000053f48, 0x2, 0x2, 0x0, 0x0, 0x4e94c0)
        /usr/lib/go/src/reflect/value.go:319 +0x16d
main.main()
        /home/vikke/go/src/github.com/reflection/main.go:18 +0x2aa```
なエラーが出ます。</pre>
<pre>vikke 2日 00:40:44: Go, 難しいアルネ</pre>
<pre>vikke 2日 00:41:03: ってか、rubyに毒されすぎてたよ。わたし。</pre>
<pre>mattn 2日 00:41:56: お昼と同じ間違いしてますよ。</pre>
<pre>mattn 2日 00:42:01: method1 が小文字。</pre>
<pre>vikke 2日 00:43:51: 死にたい。</pre>
<pre>vikke 2日 00:45:48: 通りました。本当に死にたい。</pre>
<pre>mattn 2日 00:50:48: YATTA &gt; 通りました</pre>
<pre>johejo 2日 04:51:08: <https://golang.org/pkg/net/http/#Server.Shutdown>
ちょっと気になるんですが、このexampleのShutdownってListendAndServeよりも先に呼ばれることがあり得るような気がするんですが、特に気にしなくて良いのでしょうか。</pre>
<pre>tennashi 2日 07:52:37: 先に呼ばれたとしても、ListenAndServe は ErrServerClosed を返して即 return するだけなので問題なさそうに思います</pre>
<pre>ゴリラ 2日 09:11:02: <http://go.shibu.jp/effective_go.html|http://go.shibu.jp/effective_go.html></pre>
<pre>ゴリラ 2日 09:11:08: 久々読んでみたけど</pre>
<pre>ゴリラ 2日 09:11:36: newってみんな使うかな</pre>
<pre>ゴリラ 2日 09:11:45: ぼくは最近使わなくなったけど</pre>
<pre>ゴリラ 2日 09:12:14: &amp;gorilla{}
ってやることが多い</pre>
<pre>0Δ 2日 09:13:27: channel作成する時はいつもnew使ってますねー</pre>
<pre>mattn 2日 09:14:25: もしかして：「make」</pre>
<pre>0Δ 2日 09:15:05: あ、makeだったか (いつもコピペなのがバレる)</pre>
<pre>ゴリラ 2日 09:16:11: みんなのnewを使う場面を知りたい</pre>
<pre>eihigh 2日 09:25:43: ~型つきでnilを得たいとき…だけですかね~</pre>
<pre>eihigh 2日 09:25:49: あ、うそ</pre>
<pre>mattn 2日 09:25:50: 場面というか new じゃないとできない物があるので。</pre>
<pre>mattn 2日 09:26:09: ```v := new(int)
*v = 1```</pre>
<pre>mattn 2日 09:27:10: それ以外について(例: struct)は違いはないですが、リテラルの方は linter で警告できるチャンスがあります。</pre>
<pre>eihigh 2日 09:28:57: <https://github.com/google/wire/blob/65ae46b7eaa146e99673e290251ea26f28139362/internal/wire/testdata/FieldsOfImportedStruct/main/wire.go#L31-L35>
"ポインタ型を" newするっていう珍しいケース。自分が知る限りだとこれくらいかな</pre>
<pre>mattn 2日 09:29:58: AWS のライブラリだと平気で `*string` をフィールドに持ったりするんで new 無いと死んでしまう。</pre>
<pre>ゴリラ 2日 09:32:16: なるほど</pre>
<pre>itchyny 2日 09:35:50: google/go-githubとかもそうなんすよね…</pre>
<pre>mattn 2日 09:36:31: Java やってた人が Go のライブラリ作るとなりがちという偏見を持っています。</pre>
<pre>itchyny 2日 09:36:39: <https://pkg.go.dev/github.com/google/go-github/v30/github?tab=doc#Repository></pre>
<pre>itchyny 2日 09:37:03: mapもptrでもっとるな…</pre>
<pre>eihigh 2日 09:37:17: go-githubつらいと思ってたけど間違ってなかった。</pre>
<pre>mattn 2日 09:38:25: ```Permissions         *map[string]bool `json:"permissions,omitempty"````
これは意味あるのw</pre>
<pre>itchyny 2日 09:38:38: ww</pre>
<pre>mattn 2日 09:39:13: string や int は nil 判定できないから分からんでもないけど map は nil 判定できるし、単に開発者がポインタで揃ってないと気持ち悪いからって理由でやってる様にしか見えない。</pre>
<pre>itchyny 2日 09:39:21: ポインタに統一しておきたかった、などと供述しており</pre>
<pre>johejo 2日 09:51:24: mapやsliceなんてそのままでポインタみたいなのものなのになあ
ポインタのポインタはポインタ.... 意味不明...</pre>
<pre>dohq 2日 09:56:50: aws-sdk、ほんとポインタだらけでたまに直接デリファレンスしてんぁーってなる…</pre>
<pre>kuu 2日 09:57:32: ポインタのポインタを見ると頭がバグる</pre>
<pre>kuu 2日 09:58:08: そんなに難しい概念でもないと思うんだけども</pre>
<pre>0Δ 2日 09:58:48: ポインタのポインタを何の抵抗もなく受け入れてしまえるのは何故だろうか……
いやパフォーマンスは悪いだろうけど</pre>
<pre>vikke 2日 10:28:51: リフレクション楽しいですけど難しい。</pre>
<pre>mattn 2日 10:29:47: ちなみに遊びでならいいんですが、昨日の話の様に Go で reflect 使うのかなり特異な要件なので、使わないで済むなら使わない方がいいかもです。</pre>
<pre>vikke 2日 10:35:33: そうですね。KoRoNさんも言ってたし。</pre>
<pre>koron 2日 10:36:50: まじでGo初心者がreflect使うのはやめたほうが良い。</pre>
<pre>koron 2日 10:37:12: 正しく動かすには馬鹿みたいにコードが長くなってGoの旨味なにもなくなるから</pre>
<pre>kuu 2日 10:45:47: Javaで必要に迫られてリフレクション使ったことあるけど反吐が出るような思いでコード書いてたな</pre>
<pre>kuu 2日 10:45:50: あれは地獄</pre>
<pre>koron 2日 10:46:23: 名前の文字列を間違えてメソッド呼び出せなくてってのはあるあるですよねw</pre>
<pre>tsuyoshi_cho 2日 10:47:05: python-c++バインディングで中身取り出しに使ったくらいだな、最近は。
基本言語の機能を使うだけ(not reflect)で実現できることで設計するのが普通というか普通に設計するとその言語の機能で実現できることになる、はずみたいなくらいには大概の言語は機能が足りてる</pre>
<pre>tsuyoshi_cho 2日 10:47:23: 文字列で表れるのSQL味がある</pre>
<pre>koron 2日 10:47:23: 名前の部分定数にしときゃ大丈夫だろって思ったら、その定数の値がまちがってたみたいなのもあるあるですね!</pre>
<pre>kuu 2日 10:47:33: リフレクションが必要なのって大体ライブラリが悪いんすよ、ほんとに</pre>
<pre>0Δ 2日 10:50:07: pythonみたいな動的メソッド定義をしようとreflect使った事があるけど、それやるならmap使ってチェックした法が色々安全だとわかったこのごろ。</pre>
<pre>vikke 2日 10:55:28: 以前javaでreflection使って、良い感じになったのに味をしめてる。</pre>
<pre>mattn 2日 10:55:35: 昔 junit3 と junit4、どっちでも動かせる様にリフレクションのコード書いたけど、あの時間は本当に無意味だった。</pre>
<pre>tennashi 2日 10:58:13: リフレクション多用しないといけないのであれば動的型付け言語使ったほうが幸せになるだろうなぁと思ったりしますね</pre>
<pre>koron 2日 10:58:49: ぼくはリフレクションでディスパッチは言語問わず悪いアイデアだと思いますねぇ。</pre>
<pre>koron 2日 10:59:50: 仕事でそういうコード見せられたらガチギレする自信あるw</pre>
<pre>thinca 2日 11:00:07: duck typing...</pre>
<pre>tsuyoshi_cho 2日 11:01:01: 安全制御が低いduck typingはeasy reflection感があるけど...まあ大概は実害はないか</pre>
<pre>tsuyoshi_cho 2日 11:01:27: 静的コンパイルされるduck typingはまあ...というところ(好みの問題)</pre>
<pre>kuu 2日 11:01:48: 最適化の兼ね合いとかもあって、動的型言語でもその手のコードは禁忌扱いされてたりするイメージ</pre>
<pre>kuu 2日 11:02:10: それ以前に人間にやさしくない</pre>
<pre>thinca 2日 11:04:27: Vim script と言う言語があって</pre>
<pre>tsuyoshi_cho 2日 11:06:36: 変数展開した関数定義したり、execで文字列実行したり(evalもある)、他にも多数w</pre>
<pre>koron 2日 11:06:40: こういう条件でディスパッチしてますよ、っていうのがコード構成ではなく言語構造のほうにはみ出てしまうのがアウトだと私は考えてます。やったほうがスマートに見えるんですが、あとあとの読むときを考えると、ね。</pre>
<pre>eihigh 2日 11:15:07: 以前読んだPHPのコードは、名前でメソッド呼び出すせいでそこから先のコードが死ぬほど追いづらかった。トラウマ</pre>
<pre>eihigh 2日 11:15:32: 代入タイミングと、呼び出す箇所と、呼び出されるコードがてんでバラバラで…</pre>
<pre>mattn 2日 11:57:27: reflect が楽しい、というのは(個人的には)わかる。</pre>
<pre>johejo 2日 11:59:56: interface{}を受ける関数でsliceでもstringでもbyteでもなんでもこいやってやつを作ってテストを書いて完成するとしてやったり感が結構大きい。
なおバグの温床</pre>
<pre>mattn 2日 14:17:07: ふと思ったんだけど、先日の bradfitz の `if err {}` の proposal、typed nil を解決してくれるなら嬉しい奴じゃないです？</pre>
<pre>ゴリラ 2日 14:41:52: typed nil はなにかまだ良くわかっていない</pre>
<pre>mattn 2日 14:42:47: <https://play.golang.org/p/LXAxSdzP6s-></pre>
<pre>ゴリラ 2日 14:42:59: ```var i interface{} = nil```</pre>
<pre>ゴリラ 2日 14:43:24: なる</pre>
<pre>ゴリラ 2日 14:43:43: ```var x *int = nil```
これ、nilにならないのは、型情報を持っているから？</pre>
<pre>mattn 2日 14:45:35: nil にならない、ではなくそれを interface{} に入れて比較してるのが NG って話です。</pre>
<pre>koron 2日 14:45:37: 「型情報を持ってない」ではなく「型情報が一致しない」</pre>
<pre>mattn 2日 14:45:45: はい、そういうこと。</pre>
<pre>eihigh 2日 14:46:25: untyped nil != (*int)nil
ってことです？</pre>
<pre>mattn 2日 14:46:33: yep</pre>
<pre>ゴリラ 2日 14:47:34: まだ理解できていない</pre>
<pre>ゴリラ 2日 14:47:37: ふむ…</pre>
<pre>mattn 2日 14:48:21: 「俺(interface{})には俺なりの美学(nil)があるし、お前(*int)にはお前なりの美学(nil)がある、それだけの話だ」</pre>
<pre>ゴリラ 2日 14:48:29: そもそも `nil`ってなんだ…</pre>
<pre>mattn 2日 14:49:22: nil はなんにでもなれるわけではない。</pre>
<pre>kuu 2日 14:49:24: 値が無効であることを示す値と認識していたけど、違う？</pre>
<pre> 2日 14:49:31: </pre>
<pre>mattn 2日 14:49:41: いや、なれない。</pre>
<pre>ゴリラ 2日 14:49:43: <https://text.baldanders.info/golang/nil-is-nil/></pre>
<pre>ゴリラ 2日 14:50:37: ```実際にはこれは「型がない」ことを示している。 同様に値についても，厳密には nil という値ではなく「値がない」ことを示しているのだ。```</pre>
<pre>ゴリラ 2日 14:50:39: なるほど</pre>
<pre>eihigh 2日 14:51:26: constもですが、untyped hogehogeって特別扱いされる型があるんですよね〜。</pre>
<pre>ゴリラ 2日 14:52:38: んー、難しい</pre>
<pre>mattn 2日 14:54:28: untyped は扱うのは楽だけど理解が若干難しくなりますね。</pre>
<pre>mattn 2日 14:54:54: Go だと四則演算(特に int64 vs float64)はキャストが必要だけど</pre>
<pre>mattn 2日 14:55:04: ```const v = 1
func main() {
	var f float64
	var n int64
	println(n + v)
	println(f + v)
}```
untyped だとこういう事ができる。</pre>
<pre>eihigh 2日 15:03:20: リテラル `1` は untyped int だし、リテラル `nil` は untyped nil、
いずれも代入すると型が確定する。
```var i int = 1 // ただのint```</pre>
<pre>eihigh 2日 15:03:53: ~なんだけどinterface{}に代入するとuntypedのまま入っちゃう感じ。かな~</pre>
<pre>tsuyoshi_cho 2日 15:04:01: 静的で型強めな言語でのブラックホールというところですねえ...</pre>
<pre>koron 2日 15:04:08: そのばあい `interface{}` っていう型の nil になるんすよ。</pre>
<pre>eihigh 2日 15:04:25: ああそうだ。この場合どう表現するんだ…</pre>
<pre>mattn 2日 16:38:10: <https://i101330.hatenablog.com/entry/2018/08/26/004005></pre>
<pre>mattn 2日 16:38:32: わかる～って感じの記事。</pre>
<pre>tyru 2日 16:41:33: わかりみが深い
考える事が少なくて済んで本当に楽…
try 〜 catch だとどこでキャッチするか考えないといけないし、いつ例外飛ぶか分からないし（C 書いてて安心感があるのはそれ）</pre>
<pre>tsuyoshi_cho 2日 16:44:05: まあ手続き的にはそうですね、という感覚はわかる(逆にそれ以外がないことの保障が大変だけど)</pre>
<pre>mattn 2日 16:44:06: early return していって関数全体で考えないといけない異常系をどんどん消去法ぽく消していけるので脳が楽になる感じ。</pre>
<pre>mattn 2日 16:44:21: <https://twitter.com/mattn_jp/status/1031464214282432512></pre>
<pre>mattn 2日 16:46:58: `if err != nil` 面倒！ `throw` が欲しい！って人達より、実は Go やってる人達の方がめんどくさがり屋なのかもね。</pre>
<pre>tyru 2日 16:48:27: panic() もそうですけど、大域脱出を許しちゃったらそれこそ台無しなんですよねー…</pre>
<pre>tsuyoshi_cho 2日 16:48:32: 記述の文句は、たぶんthrowより言語的な明確さがないことと、スペース区切りな複数単語だからという気がしないでもない
(try/catchと差はそこまでないと思うので...)</pre>
<pre>tyru 2日 16:49:43: あ、さっきの記事でミス見つけた… これコンパイルエラーにならんのだっけ…
```// err != nil
if err := db.Get(user); err := nil {```</pre>
<pre>mattn 2日 16:50:02: ミスぽいですね。</pre>
<pre>tyru 2日 16:50:36: Go はいっそ shadowing を禁止してほしかった（極端）</pre>
<pre>tsuyoshi_cho 2日 16:51:04: ミス記述を許しちゃうのは、ちょっとだけnnnみたいな(Cのifで代入、みたいな)</pre>
<pre>tyru 2日 16:55:06: まぁでも概ね快適なんですよね。これぐらいなら lint で検知できそうなレベルだし</pre>
<pre>mattn 2日 16:55:17: や、ビルドは通らないっす。</pre>
<pre>tyru 2日 16:56:31: おっとなるほど。すみません
最近 Go 書いてないのがバレてしまう…</pre>
<pre>tsuyoshi_cho 2日 16:56:50: あ、検知できるならfoooってカンジですねw(うるさい)</pre>
<pre>tyru 2日 17:03:56: 仕事で Go 書きてえ</pre>
<pre>vikke 2日 17:26:38: ```package main

import "log"

type I interface {
	Do(s string)
}

type S struct {
	S string
}

func (sp *S) Do(s string) string {
	return sp.S + s
}

func main() {
	s := S{S: "abc"}
	tmp := s.Do("foobar")
	log.Println(tmp)
}```
これって、`(sp *S) Do(s string) string`ってinterfaceを実装したmethodと言えますか?</pre>
<pre>tennashi 2日 17:27:23: 関数のシグネチャが違うので言えないですね</pre>
<pre>vikke 2日 17:27:57: ```type I interface {
	Do(s string) string
}```
だと良いのか。</pre>
<pre>tennashi 2日 17:28:05: ですです</pre>
<pre>vikke 2日 17:28:24: 明示的にimportしないから、良くわからなくなる。</pre>
<pre>vikke 2日 17:29:58: javaだと、 `List l = new LinkedList()` みたいに抽象化にInterfaceつかえるけど、Goでの使い方が今一ピンと来てない。</pre>
<pre>koron 2日 17:31:19: 重箱の隅ですが `I` っていう名前は慣習的にNGで、この場合なら `Doer` とする。</pre>
<pre>vikke 2日 17:31:31: ほー。</pre>
<pre>vikke 2日 17:32:19: 行為者、実行者(Doer)</pre>
<pre>kuu 2日 17:33:00: 関数に渡す上での使い方はJavaの物とそんなに変わらない気がする</pre>
<pre>vikke 2日 17:33:51: 頭の切り替え必要。</pre>
<pre>kuu 2日 17:35:21: 必要な物を実装していった結果、インターフェースを満たす、みたいなイメージかな</pre>
<pre>vikke 2日 17:35:55: ｴｰ!!!</pre>
<pre>kuu 2日 17:36:23: この考えで合ってるのかわからないです</pre>
<pre>tyru 2日 17:37:22: 基底である (implements を書く) 必要がないですからね。
ダックタイピング的 (structural typing といった方がいいんだろうけど) にユーザがほしいメソッドだけ切り出してインターフェースを定義するみたいな</pre>
<pre>tyru 2日 17:40:02: 提供者側がインターフェースを公開するまでもなくユーザ側で定義すれば、それを満たすどんな struct も受け取れるので</pre>
<pre>tennashi 2日 17:46:48: <https://play.golang.org/p/7QMKI6Q3JKL>
これより
<https://play.golang.org/p/pzk7LuyCBn4>
こっちのほうが好まれる感じですね</pre>
<pre>koron 2日 17:47:21: マルチファイルのgoplayground、たぶん慣れない人にはわかってもらえない…</pre>
<pre>koron 2日 17:48:41: これ入れるとわかりやすくなる。 <https://chrome.google.com/webstore/detail/go-playground-addons/kjhcofplemokahbgknjgabnkidaabnde></pre>
<pre>tyru 2日 17:53:59: （複数上げれたんだ…）</pre>
<pre>mattn 2日 17:54:19: implements を書かなくてもいいので余計に名前重要。</pre>
<pre>kuu 2日 17:54:24: 何気に高機能</pre>
<pre>hrsh7th 2日 17:57:39: go の interface はあるライブラリの依存コードを、その利用箇所に置けるのが好きです。</pre>
<pre>hrsh7th 2日 17:58:08: 説明が難しいですが。</pre>
<pre>tennashi 2日 17:58:27: レイヤードアーキテクチャとかクリーンアーキテクチャを Java のサンプル通り実装しちゃうと提供側にインターフェイス書きまくってしまってあれになりがち...</pre>
<pre>hrsh7th 2日 17:59:10: Java だと、モデル的なところで implements 書かなきゃなのでピュアな部分に依存が発生してくる。</pre>
<pre>tyru 2日 18:00:04: そこで DI</pre>
<pre>tyru 2日 18:03:26: Go だと複雑な仕組みがいらないのがよいですね</pre>
<pre>hrsh7th 2日 18:04:19: ファイル単位で見たときに依存コードの位置が適切になるというか…</pre>
<pre>kuu 2日 18:11:21: DIは人類には早かった</pre>
<pre>mattn 2日 18:12:17: しかしサルでも分かる。 <https://qiita.com/hshimo/items/1136087e1c6e5c5b0d9f></pre>
<pre>kuu 2日 18:12:34: `encoding/gob`の存在を知ったのでjsonである必要のない箇所を差し替えたらやりとりされるデータのサイズが半分くらいになって小躍りしてる</pre>
<pre>thinca 2日 18:13:42: ゴリラにわかるかどうかが分かれ目</pre>
<pre>kuu 2日 18:14:12: つまりゴリラさんが理解できればいいのか（ふつうに:rikai: って言い出しそう）</pre>
<pre>mattn 2日 18:14:19: サル：DI わかる
ゴリラ：わかるかも
人間：DI わからない</pre>
<pre>tsuyoshi_cho 2日 18:17:08: 言語の仕組みについて繰り返し練習しないと覚えられそうにない...という感覚がある(DIが必要になるタイプの経験があまりない..)</pre>
<pre>kuu 2日 18:18:01: 猫でも分かるとか猿でも分かるとか書いてあるシリーズ大体人類には厳しいので知性とは…みたいになる</pre>
<pre>dohq 2日 18:20:03: 野生の本能的なアレに左右されるのかもしれん</pre>
<pre>mattn 2日 18:29:34: Go の場合、Java みたいな DI ってコスト高くなって見通し悪くなりそう。</pre>
<pre>tyru 2日 18:32:16: 正直自分も Scala のこのパターンに触れるまで DI って Spring の動的なやつしか触れた事なかったから実行時にエラー起きるし悪い印象しか持ってなかったけど、
ちゃんと静的に DI の役目を果たせてるじゃん、ってなった覚えがあるなー
<https://qiita.com/pab_tech/items/1c0bdbc8a61949891f1f></pre>
<pre>tyru 2日 18:33:00: Scala といい DI といいさすがにオフトピすぎたｗ</pre>
<pre>itchyny 2日 18:33:33: Cake 僕も好き</pre>
<pre>tyru 2日 18:34:52: ↑のは Cake をよりシンプルにしたやつですね。UsesXXX と MixInXXX を公開して trait/object で extends するだけ</pre>
<pre>thinca 2日 18:35:01: 実は DI が何者なのか全くわかっていない</pre>
<pre>mattn 2日 18:36:17: Cake パターンって名前知ってたけどこういう意味だったの。
&gt; 「僕のケーキに対する敬意という以外の理由としては、ケーキが（ジャムで分けられた）レイヤーから成り、またそのケーキを切り分けることができるということが挙げられる。レイヤーは内部クラスの入れ子構造を表す。上から順にたどっていく事で底辺のレイヤーに行き着くのが似ていると言えなくもない。また、ケーキの一切れは、プロジェクト内のコンポーネントを表し、いくつかのレイヤーを横断して切ることになる。」</pre>
<pre>tyru 2日 18:36:54: Onion といい Cake といい開発者は食べ物に例えがち</pre>
<pre>tyru 2日 18:37:23: DI は一番簡単な constructor injection から考えるのが分かりやすいと思う</pre>
<pre>mattn 2日 18:39:10: Java は DI をアノテーションで難しくしてしまったので、みんな DI がなんだか分からなくなった。</pre>
<pre>hrsh7th 2日 18:40:16: new する箇所を設定ファイル的に切り出す + すべて interface への依存にする =&gt; テストしやすいし、インスタンスも設定で切り替えられる =&gt; 副産物的にコンストラクタでの依存解決も同時に可能になった（すべてのインスタンス生成方法を知ったため）
こういう認識です。</pre>
<pre>tyru 2日 18:41:52: 設定ファイルもいらない認識です</pre>
<pre>koron 2日 18:42:09: DIかどうかはともかくとして、コンポーネント間の依存が複雑になるとコンポーネントの初期化がオブジェクトの引き渡しで実質スパゲッティになるんですよ。それを切るってのがDIの目的の一つ。</pre>
<pre>hrsh7th 2日 18:42:57: 設定ファイル的にというのがニュアンスでした :bow: （無名関数で生成処理を切り出すのも設定ファイル的だ。と解釈してます。）</pre>
<pre>tyru 2日 18:43:02: 自分はむしろ Spring とか設定ファイルで管理する方法の利点が正直わかってない</pre>
<pre>tyru 2日 18:43:15: なるほどです</pre>
<pre>koron 2日 18:43:22: コンパイルせずに振る舞いを変えられる。</pre>
<pre>tyru 2日 18:43:54: あーなるほど。運用だけで振る舞いを変えられるということですか</pre>
<pre>koron 2日 18:44:24: 運用まで行かなくとも、コンパイルが遅いやつには有利かも?</pre>
<pre>hrsh7th 2日 18:44:43: そうか、新しく追加したクラスファイルだけ追加でコンパイルして xml いじったら振る舞いを変えられるというのが利点なのか。Java ほとんど書かないので盲点でした。</pre>
<pre>tyru 2日 18:45:31: 正直自分的には動的に注入することによって実行時にエラーが起きる方が怖いと思うのであまり感覚が分からないです。。。</pre>
<pre>tyru 2日 18:45:45: でもそういう要求はあるんだろうなというのはわかります</pre>
<pre>mattn 2日 18:45:55: DI を Java から知ると設定ファイルのイメージありますよね。</pre>
<pre>koron 2日 18:46:02: 僕が仕事で書いて使ってる go用のDIっぽいの。DIとは謳ってないけどw
<https://github.com/koron-go/materialize></pre>
<pre>koron 2日 18:46:17: *component's dependency separator*</pre>
<pre>mattn 2日 18:47:18: コンストラクタでインタフェース貰う様な注入形式で考えると分かり良いすね。</pre>
<pre>hrsh7th 2日 18:47:31: インスタンスの生成処理を切り出したことでシングルトンなオブジェクトを注入もできるか。。。
やっぱりいちばんめんどくなりがちな「インスタンスを生成・管理する箱」ができたから、それによってできることは全部やろうってテクノロジーなきがしますね。（だから言語化しづらい）</pre>
<pre>mattn 2日 18:48:36: 抽象化する為に昔からやってた事に DI なんてヘンテコな名前が付いてしまったのが諸悪の根源ぽさある。</pre>
<pre>koron 2日 18:48:44: googleのコード生成式のもあったけど、いくつかの理由でダイナミックなほうが良いなってなった。</pre>
<pre>tyru 2日 18:48:56: 関係ない話ですけど Java から入ったから最初インスタンス生成のタイミング・インスタンスの生存期間って DI と関係あると思ってました…</pre>
<pre>tyru 2日 18:50:33: シングルトンとか絡んでくるとそういうのも考慮しなきゃいけないのはわかる（けど混乱した）</pre>
<pre>eihigh 2日 18:50:55: Goはwire
ですね、有名どころ
あんま使う気はしないけど…</pre>
<pre>koron 2日 18:51:31: まぁ、Javaのやつはほんとツラいよね。ソースコードが馬鹿みたいに追いにくい。

注入されたのがコード生成されたやつだったりすると絶望しかかる。</pre>
<pre>mattn 2日 18:51:39: 使った事ないな。wire って名前からするに Java の Autowired な感じなのかな。</pre>
<pre>koron 2日 18:52:20: コンストラクタ用の関数いっぱい書いておいて、あとは自動でそれを呼び出すコードを生成する感じ。</pre>
<pre>vikke 2日 18:52:45: 仕事は終わった。これからはreflectionのお時間ぬははははは</pre>
<pre>mattn 2日 18:52:53: 関数シグネチャで解決する感じかな？</pre>
<pre>koron 2日 18:53:09: そんなイメージ</pre>
<pre>tyru 2日 18:56:53: 最初の <@U03C71D7H> さんの疑問に乱暴だけど一番簡単な形で答えると、DI はコンストラクタに中で使うインスタンスを全て渡すのと同じってことです。
これはコンストラクタ注入 (constructor injection) といって立派な DI 手法の一つです</pre>
<pre>johejo 2日 18:57:54: wireいいですよ コンストラクタインジェクションの手書きから移行しやすい</pre>
<pre>tyru 2日 18:57:55: DI・テストに一家言ある Kuniwak さんの記事とか見るとわかるかも…
<https://twitter.com/orga_chem/status/1037991810868555776></pre>
<pre>mattn 2日 18:58:48: インスタンスを作るというコードは、インスタンスを作る為に必要な要素(コンストラクタ引数)が増えがちで、そのたびにそれを生成している個所を弄らないといけなくなる。これが問題。なので外から生成済みの物をもらう。</pre>
<pre>thara 2日 18:59:09: DI=DIコンテナと考えちゃうと難しく思えちゃうんですよね</pre>
<pre>thinca 2日 18:59:40: 少なくとも意識して使ったこと一度もないのだよな…</pre>
<pre>johejo 2日 18:59:54: コード生成方式は何よりリフレクションベースじゃないのでコンパイル時に依存の刺し忘れに気づけるし起動も速い</pre>
<pre>tyru 2日 19:00:22: 多分 thinca さんだとテスタブルにするために無意識に使ったことあるかもしれない</pre>
<pre>tyru 2日 19:00:48: 仰々しい名前が付いてるけど大したことはない</pre>
<pre>mattn 2日 19:01:41: わかり良い例だとロガーかな
&gt; ファイルに出力なのか標準出力に出すのか良く分からないけど、とりあえずロガーを貰ってログを吐きたいコードはある、でもファイル名を引数で貰う様な事はしたくない、俺はロガーを欲しいし、ファイルか標準出力かなんて気にしたくない。</pre>
<pre>kuu 2日 19:01:45: リフレクションベースの何がアレってIDEによるリファクタリングがしづらいのが</pre>
<pre>kuu 2日 19:02:01: 文字列なので書き換えてくれなくってつらい</pre>
<pre>thinca 2日 19:02:16: ロガーわかりやすい</pre>
<pre>tyru 2日 19:02:59: ロガーは実際 logback とかでそんな感じで設定ファイルで指定しますね</pre>
<pre>mattn 2日 19:03:19: Ruby で1枚岩のコード書くとログ出力をファイル、標準出力、を切り替えるコードが本体になっちゃうんですよね。これだと切り替えたいケースでソースを弄らないといけない。</pre>
<pre>koron 2日 19:03:33: 僕のやつ、structポインタでも interface でも要求できる。もちろん登録忘れてたらランタイムにエラーになっちゃうけどw</pre>
<pre>johejo 2日 19:03:51: Goだとuberのdigとかfxが結構有名ですかね。どっちもリフレクションベースですが</pre>
<pre>mattn 2日 19:04:34: で、ロガーを貰う方法としておおまかに
* コンストラクタ経由で貰う方法
* フィールドで貰う方法(アノテーション付けたりする)
の2種類くらいがあります。</pre>
<pre>koron 2日 19:05:00: 僕、後者のやつ嫌で採用しなかった。</pre>
<pre>mattn 2日 19:05:23: つまり Java が嫌い、とw</pre>
<pre>johejo 2日 19:05:25: ライフサイクルの管理とかいろいろやりたくなるとリフレクションベースのが欲しくなる</pre>
<pre>tyru 2日 19:05:54: コンストラクタだとどうしても引数が増えちゃうのが難点なんですよね…</pre>
<pre>johejo 2日 19:06:45: AutoWired便利なんですけどね 最初は</pre>
<pre>koron 2日 19:07:53: その引数すらDIで調達しちゃうイメージ。</pre>
<pre>thara 2日 19:09:03: フィールドインジェクションだと、コンストラクタの引数が増える=そのクラスが依存する先が多い、という設計上の問題を感じづらくなるのでJavaコミュニティでも好まれてないと思います</pre>
<pre>tyru 2日 19:09:04: つまりこのどちらでもないってことです？
&gt; * コンストラクタ経由で貰う方法
&gt; * フィールドで貰う方法(アノテーション付けたりする)</pre>
<pre>thara 2日 19:10:13: （少なくとも今は…)</pre>
<pre>tyru 2日 19:10:56: 時代は変わった…（あるいは私の見ていた Java コミュニティが違っていた…）</pre>
<pre>ゴリラ 2日 19:11:21: DI、便利だと思いつつ、どういった場合に使うのがベストなのか、あんまわかっていない</pre>
<pre>koron 2日 19:11:28: コンストラクタとしてシンプルな関数を登録しておくんです。

`func() (*T, error)` みたいなね。

そうすると *T か *T が満たす interface を要求したときにこの関数が1度だけ呼び出されるようになってるんです。

で、この関数からDIを呼び出して必要な引数をパッケージした値を要求できる。</pre>
<pre>ゴリラ 2日 19:11:43: そもそもDIあんま使わないので、そこらへんわかっていないのか</pre>
<pre>mattn 2日 19:12:10: 疎結合を究極的に突き止めていくと、おそらくそれが DI になってます。</pre>
<pre>johejo 2日 19:12:33: シングルトンの管理とかテスタビリティを高めるためにわりと自然に使ってると思いますね</pre>
<pre>ゴリラ 2日 19:12:39: 疎結合 = DI のイメージしかない</pre>
<pre>ゴリラ 2日 19:13:00: 疎結合にする ＝ DIするよ
って解釈しています</pre>
<pre>kuu 2日 19:13:34: メッセージパッシングによる疎結合も見たことある</pre>
<pre>koron 2日 19:13:59: 正確に言うと、この登録する関数が必要な場所から必要な方法で好きに引数を集めてこれるってことかな…</pre>
<pre>koron 2日 19:14:49: rubyとかobjectc?w</pre>
<pre>tyru 2日 19:14:50: あーなるほど。
`map[string]func()(*T, error)` みたいなテーブルに登録して by name で呼び出すってことです？

ただそれだと正直フィールドで貰う方法とやってることは変わらないような…？
と思ったけど、明示的に↑のコンストラクタを呼び出すってことですかね？</pre>
<pre>koron 2日 19:15:19: いやいや名前じゃなくて型で呼び出すんですよ。</pre>
<pre>johejo 2日 19:15:28: DIは単に疎結合というよりは交換可能性をうまく高めておくてことだと思ってます</pre>
<pre>koron 2日 19:15:37: <https://github.com/koron-go/materialize/#gettings-started></pre>
<pre>koron 2日 19:15:45: ↑の例見ていただけると。</pre>
<pre>tyru 2日 19:15:57: あ、そうでした。string じゃなかった</pre>
<pre>mattn 2日 19:16:48: &gt; 俺はロガーが欲しい。ロガーを作る処理を本体に書きたくないし、ロガーをどこかで生成して俺のコードに渡すようなコードも書きたくない。俺のコードのインスタンスが死んだらロガーは一緒に消えて欲しいが、もっかい俺のコードのインスタンスが生成された時にさっきのが欲しいか、もう一度作りなおしたのが欲しいかは、のちのち決める。
わがまま言いたい放題やな。</pre>
<pre>koron 2日 19:17:49: フィールドでやるやつだとマッピングの振る舞いが暗黙的になっちゃうんですが、この方法だと明示的にどこから取ってくるってのをコードで書くことになるんです。

複数の値をいっぺんに取ってきて1つでも取れなかったらエラー、みたいなのを書きやすくしてます。</pre>
<pre>mattn 2日 19:18:21: wire は Build で依存関係作ってコマンドで wrapper 吐く感じか。</pre>
<pre>koron 2日 19:19:57: 実は

`func(mx *materialize.Context) (*T, error)`

っていう関数も登録できてこの mx を通じていい感じに必須で要求したり、無くてもよいよ～ってのを書けるんです。</pre>
<pre>koron 2日 19:21:10: 交換可能性がテスト用途だけならオーバーキルだと思ってて、またそれ以外で実際に入れ替えることが僕の経歴上にはなかったよ…</pre>
<pre>johejo 2日 19:22:38: コード生成方式のwireは型で判別するでコンストラクタにプリミティブ型が渡せないからいちいちaliasをはったりしないといけないところがちょっと面倒</pre>
<pre>mattn 2日 19:23:07: そうなんよねー。DI で抽象化したコード何度か書いたけど、テスト以外で実際にリポジトリを入れ替えた事ってまぁ無いんだよなw Mock くらい？</pre>
<pre>koron 2日 19:23:25: えmockてテスト用途以外で?</pre>
<pre>mattn 2日 19:23:34: や、テストで</pre>
<pre>tyru 2日 19:23:34: なるほどなるほど。明示的にやるのはいいですね。
フィールド + アノテーションで暗黙的にやっちゃうと、アノテーションつけ忘れただけでぬるぽったりするので。</pre>
<pre>mattn 2日 19:24:43: 綺麗になる、テストが楽、がメリットなんだけどそれやる為にだいぶ苦労してる。</pre>
<pre>johejo 2日 19:25:46: mongoやめてRDBに戻したときにちょっとだけ助かった。ちょっとだけ</pre>
<pre>koron 2日 19:28:15: 11行目の mx.Resolve で循環参照が切れる。</pre>
<pre>koron 2日 19:29:33: 12～14行目の文字列は、ヒント情報。interfaceで要求して被った場合に1つに絞り込むために利用する。</pre>
<pre>tyru 2日 19:31:09: 一応 Java (というか Spring) の擁護もしておくとｗ
`@Autowired Foo foo;` なフィールドに対して、↑のライブラリと同じように `Foo` を生成するメソッドを指定することはできます。なので「コードで書く」ってのは一応できます。
ヒント情報で渡したり、あと `@Scope("prototype")` で注入した親インスタンスの生存期間に合わせて破棄されるとかも指定できます。</pre>
<pre>johejo 2日 19:31:14: Pythonとかだとモンキーパッチでコンストラクタ自体を書き換えてモックを挿入できたりするのでわりとどうとでもなるけどGoはそうもいかないので悩みどころですね</pre>
<pre>tyru 2日 19:31:51: まぁ単純に KoRoN さんの要件ではそこまで複雑なものは必要ではなかっただけで、「Java でもできる」ってことは重要じゃないんだろうなというのは理解してます。
（逆に too fat なんだろうなと）</pre>
<pre>koron 2日 19:32:33: そうそう。Javaでできることをやりたいんじゃなくて、Goに合った形にしたかったのね。</pre>
<pre>tyru 2日 19:34:38: Go だと割と自作してフィットする形にするのが最適解なケースは多い感ありますね。
ただそれで DI コンテナ作っちゃうのは腕力ありすぎですがｗ</pre>
<pre>thara 2日 19:34:44: &gt; テスト用途だけならオーバーキル
DIコンテナが出てきた時代はAOPとセットだった気がするので、AOPしなければ利点はだいぶ減ってしまう気がしますね</pre>
<pre>koron 2日 19:39:00: いやいやコレが結構シンプルにできてんですよw</pre>
<pre>koron 2日 19:41:19: そういやAOPも、実際何が起こっているのかわかりにくくなっただけで、僕はあんま恩恵を受けられなかったんだよな…</pre>
<pre>koron 2日 19:42:25: 書くよりも読む(動作を追う)ことが多いからなのかもだけど。</pre>
<pre>tyru 2日 19:44:13: ロギング以外に AOP 使ってるの見たことない…
その癖 AspectJ とかクラスファイル書き換えてまで実現してるし、そこまでして何がやりたいのか全然分からなかった…</pre>
<pre>thara 2日 19:48:01: 自分がAOPの価値を感じたのは、ロギングとトランザクション境界を外部から設定できる（または呼び出し元によって動的に変える）ことぐらいですね
今なら高階関数とか別の言語機構で同じようなことが実現できるので、あまり採用するモチベは湧かないですね</pre>
<pre>tyru 2日 19:50:17: なるほど。トランザクション境界 (`@Transactional` ?) も AOP で実現してたのか。
本当そうなんですよねー &gt;今なら〜</pre>
<pre>mattn 2日 19:53:35: ウェブフレームワークのミドルウェアなんかはいい例かも。</pre>
<pre>tyru 2日 19:54:07: あぁーなるほど…</pre>
<pre>tyru 2日 19:55:20: node の express とか継続っぽいことしてたな (引数の next を呼び出させる)</pre>
<pre>tyru 2日 19:56:08: (無限に脱線する性格なのでちゃんと Go の話しないと… せっかく <#CGABGC8LA|golang> を求めてきた人がいっぱい join してきてくれたばっかりなのにｗ)</pre>
<pre>vikke 2日 20:10:36: 話ぶった切ってすいません。質問です。
<https://github.com/vikke/go_reflection/blob/master/main.go#L10>
のhogeを文字列でもらった場合に、動的にhogeを作るにはどうしたらよいですか? reflectionにnamespaceやpackageに関するマニュアルを見つけられませんでした。</pre>
<pre>hokorobi 2日 20:19:07: "golang.toyko #30 - YouTube" <https://www.youtube.com/watch?v=7YGw-UIkcWw></pre>
<pre>ゴリラ 2日 20:20:25: なう</pre>
<pre>ゴリラ 2日 20:21:38: &gt; のhogeを文字列でもらった場合に、動的にhogeを作るにはどうしたらよいですか? reflectionにnamespaceやpackageに関するマニュアルを見つけられませんでした。
パッケージのDIって感じですか？</pre>
<pre>ゴリラ 2日 20:21:53: アイディアが思いつかない…</pre>
<pre>hokorobi 2日 20:24:53: 若者が頑張ってると反応してあげたい（おっさん味）</pre>
<pre>vikke 2日 20:28:38: 名前空間と構造体名とメソッド名を外から与えて、メソッドを起動出来ないかなと。
<https://golang.org/pkg/reflect/>
みてるんだけど、それっぽいのにゃい。</pre>
<pre>hrsh7th 2日 20:35:05: reflect に package を扱うものはなさそうに見えますね。（そうじゃないとバイナリに埋まってないものが参照されうるのでそりゃそうかなとは思いました）</pre>
<pre>mattn 2日 21:17:22: できません。</pre>
<pre>mattn 2日 21:18:33: 唯一やれる方法があるとすれば、"hoge" を貰った瞬間にパッケージ名 `hoge` のソースを生成して `-buildmode=plugin` でコンパイルして `plugin.Open` で読み込むくらいです。</pre>
<pre>vikke 2日 21:19:19: それはトリッキーですね。面白いです。plugin.Openっていうのがあるのですね。</pre>
<pre>mattn 2日 21:19:51: ただし unload は出来ません。</pre>
<pre>mattn 2日 21:20:08: あと Windows では動きません。</pre>
<pre>eihigh 2日 21:21:05: pluginってメンテされてるのだろうか。1.8のイメージで止まってる。</pre>
<pre>mattn 2日 21:23:00: メンテはされてると思いますが、機能的には何も足されてないですね。</pre>
<pre>mattn 2日 21:23:25: 使ってるプロダクトはありますけどね。gophernotes とか。</pre>
<pre>eihigh 2日 21:24:48: deprecatedではないけど維持はされてる感じかな…</pre>
<pre>vikke 2日 21:36:06: rubyってエラーがあった場所でreturnしちゃう事多いですけど、Goの作法ってどんな感じですか?</pre>
<pre>mattn 2日 21:37:22: 自分で early return します。</pre>
<pre>mattn 2日 21:37:35: 例外はありません。</pre>
<pre>vikke 2日 21:45:08: early returnで良いんですね。</pre>
<pre>ゴリラ 3日 00:57:23: Goで作るインタプリタ、なぜこのデータ構造なのか全然わからん</pre>
<pre>ゴリラ 3日 00:57:27: 難しすぎる</pre>
<pre>ゴリラ 3日 00:58:22: <https://github.com/skanehira/monkey/blob/master/ast/ast.go#L147-L151></pre>
<pre>ゴリラ 3日 01:02:00: 自分の理解力の無さに嘆く</pre>
<pre>ゴリラ 3日 01:02:02: 寝よ</pre>
<pre>ゴリラ 3日 01:07:02: 理解してきた</pre>
<pre>ゴリラ 3日 01:07:04: 寝る</pre>
<pre>ゴリラ 3日 01:21:23: <https://ja.m.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)|https://ja.m.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)></pre>
<pre>ゴリラ 3日 01:22:20: まず、JSONのパーサを作るところからやってみようかな</pre>
<pre>ゴリラ 3日 01:22:38: そしたら、インタプリタのパーサーも理解できる気がしてきた</pre>
<pre>mattn 3日 01:23:13: このデータ構造は InfixExpression しか枝になってないですね。</pre>
<pre>ゴリラ 3日 01:47:41: そうすね
prefixはオペレーターとleftしかないすね</pre>
<pre>vikke 3日 09:20:30: goでtemplate method patternもどきすら書けない。うぉおおおぉおぉぉ</pre>
<pre>eihigh 3日 09:23:42: デザパタもGo書くときに邪魔になるものの一つですよねえ。</pre>
<pre>tsuyoshi_cho 3日 09:24:49: 言語の構造と方針が違うから、そのままハマるのが少ないってところでしょうかね?</pre>
<pre>tsuyoshi_cho 3日 09:25:16: 理念に近いものならそれなりに翻訳できるものはあると思いますが...</pre>
<pre>eihigh 3日 09:26:12: いろんな見方はあると思うんですが
・言語が違うからうまくハマらない
・そもそも無理にデザパタは当てはめるものでもない
・いい感じにやればそれに近くなるから特に意識する必要がない
とかかなあと…</pre>
<pre>tsuyoshi_cho 3日 09:27:17: ただ、設計理念の共有のための「パターン」でもあるから
&gt;  いい感じにやればそれに近くなるから特に意識する必要がない
は、若干脳筋的で、それもどうかな、という気がしないでもないw</pre>
<pre>eihigh 3日 09:27:22: 知っといて損はないと思うんですけどね。それよかGoに入りてはGoに従う方がよりよく書ける印象。</pre>
<pre>eihigh 3日 09:28:04: デザパタちゃんと使う開発入ったことないから分からないな…共通言語として持った方が開発しやすそう（想像）。</pre>
<pre>tsuyoshi_cho 3日 09:28:05: まあ実インプリメントの時は、パターンは理念で言語イディオムで適切に実装できることが大事かな、はわかる</pre>
<pre>kuu 3日 09:28:14: Goにおけるデザインパターンのようなものに従うしかなさそう</pre>
<pre>kuu 3日 09:29:25: 一般的(?)なデザインパターンはオブジェクト指向の世界で生まれたものなので、オブジェクト指向とかけ離れたGoにそのまま適用するのは厳しいのかなって</pre>
<pre>tsuyoshi_cho 3日 09:30:32: ですねえ</pre>
<pre>kuu 3日 09:30:47: 設計理念として知っておくと便利なのには同意</pre>
<pre>eihigh 3日 09:31:52: Goの基本的なパターンこそ大事なんだけど、デザパタやらClean Architectureやらの _バズワード_ に惹かれる人が多いのかな（ド偏見）</pre>
<pre>tsuyoshi_cho 3日 09:33:09: まあ、「バズワード」と思って(そのつもりじゃなく、流行りに)寄ってくタイプはだめでしょうかね...
理解しようとして学ぶなら、無理な適用はしないとおもいます</pre>
<pre>kuu 3日 09:34:31: 例えばVisitorパターンってありますが、filepath.Walkなんてそのものな設計してますし</pre>
<pre>tsuyoshi_cho 3日 09:35:09: あれは継承というより、インタフェースの実装がされてればできるから、Goでは適用しやすい?という気はする</pre>
<pre>mattn 3日 09:35:12: template method pattern は abstruct のアレをイメージされておられるのかな？</pre>
<pre>mattn 3日 09:36:34: ```package main

type Base struct { }

func (b *Base) DoSomething() {
	println("Yes, We Can!")
}

type Derived struct {
	Base
}

func (rd *Derived) Say() {
	println("セイ")
}


func main() {
	var d Derived

	d.Say()
	d.DoSomething()
}```</pre>
<pre>tennashi 3日 09:43:41: GoF のデザパタ、何にも考えずに写経したのは役に立った気がしますね
Go の interface の使い方、どう使うと辛くなるのか、みたいなのが逆説的に理解できた気がします</pre>
<pre>mattn 3日 09:45:20: Visitor であれば go/ast に Walk する、ままなやつもありますね。</pre>
<pre>ゴリラ 3日 09:48:40: GoF、ナニモワカラナイ</pre>
<pre>mattn 3日 09:49:09: GoF の利</pre>
<pre>tennashi 3日 09:50:51: <https://github.com/mattn/gof></pre>
<pre>tsuyoshi_cho 3日 09:51:05: Go、GoFだぁ～(ちがう)</pre>
<pre>mattn 3日 09:51:26: GoF、ちょっと古いので現状にはあってない感あります。</pre>
<pre>tsuyoshi_cho 3日 09:52:05: 言語機能の少なさをカバーしてる面もあるので、もうちょっと簡素なベース語を作ってもよさそう</pre>
<pre>mattn 3日 09:52:14: 古いというか、フレームワークなんかに巻き取られてて今知る必要ないよなー的な物もある。</pre>
<pre>tennashi 3日 09:52:43: ただ語彙として知ってないと本読めないときありますよね</pre>
<pre>tsuyoshi_cho 3日 09:52:53: まあ、素データ構造とコレクションフレームワークの対比みたいなもんで、知識は必要なんだろうけど、それで会話しなくなった単語、みたいなのはありますね(一部)</pre>
<pre>mattn 3日 09:56:10: 継承がいい物じゃないとされてきつつある今だと、いくらか消えそうなやつ(継承に依存したパターン)もありそう。</pre>
<pre>tsuyoshi_cho 3日 09:57:14: まあ移譲したものをかかえれば同じ、という気もしないでもないですが...ちょっといいわましが変りますもんね</pre>
<pre>mattn 3日 10:07:47: <https://jp.quora.com/%E4%B8%80%E6%99%82%E6%9C%9F%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A8%E3%81%84%E3%81%86%E3%82%82></pre>
<pre>eihigh 3日 10:08:40: いいまとめ。</pre>
<pre>mattn 3日 10:09:10: さすゆぐい</pre>
<pre>mattn 3日 10:09:54: すぐしたに毛の壁氏が...</pre>
<pre>itchyny 3日 10:16:41: <https://go-review.googlesource.com/c/go/+/226877/> これ便利なやつでは</pre>
<pre>tsuyoshi_cho 3日 10:24:58: ゲリー、音が...(まだつかったことない)</pre>
<pre>mattn 3日 10:39:15: デバッグの為にディレクトリを残す仕組みも欲しいな。</pre>
<pre>mattn 3日 10:39:46: と思っていたら issues で bradfitz が os.Exit(1) 書いてて vote down されてたw</pre>
<pre>vikke 3日 10:52:37: ```package main

import (
	"log"
)

type Receiver interface {
	Do()
}

type MyReceiver struct {
}

func (w Receiver) Do() {
	log.Println("Do")
}

func main() {
	mr := MyReceiver{}
	<http://mr.Do|mr.Do>()
}```
これって `func (w Receiver) Do() {`で  エラーになるんですけど、Interfaceで受けるって事は出来ないんでしょうか?(まー出来ないからエラーになるんだけど)。どうやるのがGoっぽいですか?</pre>
<pre>koron 3日 10:53:46: interface にメソッドの実装はできないんすよ。少し前のJavaもそうだったでしょ?</pre>
<pre>koron 3日 10:54:06: interfaceを受け取る ~メソッド~ 関数なら書けるはず。</pre>
<pre>tsuyoshi_cho 3日 10:55:29: 上でmattnさんがやってるこれ
<https://vim-jp.slack.com/archives/CGABGC8LA/p1585874193345600>
みたいにやるのがいいのかな</pre>
<pre>vikke 3日 10:55:50: ちゃんと理解してきます。</pre>
<pre>vikke 3日 10:57:34: インターフェースに実装を書くんじゃなくて、レシーバーをインターフェースで指定出来ないかなーと。</pre>
<pre>koron 3日 10:58:26: んー意図が伝わらない。</pre>
<pre>koron 3日 10:59:04: 何をしたいのかがわからない。</pre>
<pre>koron 3日 10:59:40: まず MyReceiver は Do を実装してないので Receiver になってないですよね。そのチェックをコンパイル時にしたいってこと?</pre>
<pre>vikke 3日 11:00:20: あー、色々と僕が駄目です。出直してきます。</pre>
<pre>vikke 3日 11:07:38: 凄い初歩的な事聞きますが、MyReceiverはDoを実装していないという部分なんですが、 `func ( w Receiver) Do() {` で実装しているつもりなんですが、これでは駄目?</pre>
<pre>koron 3日 11:08:17: `func (w *MyReceiver) Do() { ...` としたほうが良いです。</pre>
<pre>vikke 3日 11:09:33: そこを、MyReceiverという構造体では無く interfaceにしたいという話です。interfaceにしたいわけでは無くて、やりたい事は、ダックタイプでDo()が呼べればなんでも良いんですけど。</pre>
<pre>koron 3日 11:09:39: ポイントは2つで、Receiver → MyReceiverにすることとポインタにすること。

ポインタにするのはメモリ効率とかその辺。I/Fで扱うと非ポインタだとboxingが起こるんじゃなかったかな。</pre>
<pre>koron 3日 11:10:11: その言い方だとやっぱ根本的にI/F理解できてない気がしますね。</pre>
<pre>vikke 3日 11:10:19: やはり。</pre>
<pre>vikke 3日 11:10:25: 出直してきます。</pre>
<pre>koron 3日 11:17:03: ちょっとサンプル書いたんでこれ実行したり書き換えたりして遊んでみてください。RunでWeb上で実行できるんで。
<https://play.golang.org/p/RTq46_kWqW4></pre>
<pre>hrsh7th 3日 11:17:37: FileLogger/ConsoleLogger とかの例を試しに実装してみる。とかのほうが理解しやすそうですね。</pre>
<pre>koron 3日 11:18:51: 普通の log.New に os.Stderr を渡すか os.Create() の戻り値を渡すかで説明できちゃうんですけどね。どっちも io.Writer 渡すわけだから。</pre>
<pre>hrsh7th 3日 11:21:25: 自分で書いてみると理解につながるとは思うんですよね。
その場合に Doer で具体的実装は一つだけ、とかを例にしちゃうと理解しづらそうだなあと感じた次第でした。</pre>
<pre>vikke 3日 11:21:56: マンモスありがとうございます。</pre>
<pre>vikke 3日 12:08:27: Syntax Errorって一番ださいよね。</pre>
<pre>koron 3日 12:11:15: まぁしゃーないんじゃない?</pre>
<pre>vikke 3日 12:30:38: それも原因がわからないSyntax Errorはださい</pre>
<pre>kuu 3日 12:33:03: Syntax Errorからの「コンパイラ壊れてる！！マジ :shit: 」はみんな通った道なのでは[要出典]</pre>
<pre>kuu 3日 12:34:02: こういう場合は大体自分が悪い(ごく稀に本当に壊れてることあるけど)</pre>
<pre>vikke 3日 12:39:49: いや、完全に自分のせいですよ。コンパイラのせいなんて0.0001%の確立では?</pre>
<pre>raa0121 3日 12:40:48: 新しい言語を書き始めてからの数ヶ月とか、逆に Syntax error 祭りでは</pre>
<pre>vikke 3日 12:42:33: ``` syntax error: non-declaration statement outside function body```
って、なんね。宣言場所間違っとるとね?</pre>
<pre>tsuyoshi_cho 3日 12:43:14: 関数の外に非宣言ステートメントがある...?</pre>
<pre>tennashi 3日 12:51:33: hoge := "hoge" を関数の外で書いたとか</pre>
<pre>tennashi 3日 12:56:27: // 俺は正しい!! これは vim のバグに違いない!! -&gt; 私が悪うございました...とか無限回やってる...</pre>
<pre>kuu 3日 12:58:00: この前やらかした時はバクレポートまで作ってんだよなぁ…提出しなくて本当によかった</pre>
<pre>johejo 3日 13:05:03: Rustなんてコンパイラとの戦いが大部分ですね....</pre>
<pre>tsuyoshi_cho 3日 13:05:44: ある説明見てたけどRustのコンパイラは丁寧で厳しい教師という感じですねえ</pre>
<pre>thara 3日 13:06:33: エラーメッセージがかなり丁寧ですよね。特にライフタイム周り</pre>
<pre>johejo 3日 13:07:49: 昔はgccとかjvmのホットスポットコンパイラよくバグってた（らしい</pre>
<pre>tsuyoshi_cho 3日 13:08:22: 目立っちゃうから、というのもあるかも &gt; コンパイラ</pre>
<pre>tsuyoshi_cho 3日 13:09:00: <https://linux.srad.jp/story/14/07/28/0945215/></pre>
<pre>thinca 3日 13:09:45: Ruby の syntax error、tokenizer レベルのエラーがそのままくるのでキビしい</pre>
<pre>mattn 3日 13:11:38: `$` とか見えるとウッってなるやつ。</pre>
<pre>mattn 3日 13:35:41: <https://github.com/golang/go/commit/dcf0929de6a12103a8fd7097abd6e797188c366d></pre>
<pre>mattn 3日 13:35:51: -h が exit(0) する様になった？</pre>
<pre>kuu 3日 13:36:30: ぽいですね</pre>
<pre>vikke 3日 13:51:08: methodの頭にfuncと書き忘れたという忘れたいミス。</pre>
<pre>mattn 3日 15:32:16: はやくこれ進展して欲しい。 <https://github.com/golang/go/issues/35950></pre>
<pre>itchyny 3日 15:34:35: <https://github.com/golang/go/issues/36982> が欲しい</pre>
<pre>yy_yank 3日 15:41:32: このチャンネルの過去のやりとり眺めてて思った素朴な疑問なんですが
Goのリフレクションの良い使用例というか、リフレクションを使って上手く書いてる良いライブラリみたいなのありますか？</pre>
<pre>yy_yank 3日 15:42:23: ユニットテストでreflect.DeepEqual書いてるのぐらいしか見たことがない…</pre>
<pre>tennashi 3日 15:42:37: encoding/json とかは使われてますよね</pre>
<pre>tennashi 3日 15:42:51: // たしか</pre>
<pre>tsuyoshi_cho 3日 15:43:20: structを動的に作るんでしたっけ?</pre>
<pre>tennashi 3日 15:44:15: <https://golang.org/src/encoding/json/decode.go></pre>
<pre>koron 3日 15:44:21: んーORM系はreflect駆使しないとできないよね。</pre>
<pre>mattn 3日 15:44:31: anko という、Go ぽいインタプリタを作ってます。anko から Go のオブジェクトを Go ぽく操作できる様にしてるので vm はフル reflect です。</pre>
<pre>mattn 3日 15:44:57: <https://github.com/mattn/anko/></pre>
<pre>koron 3日 15:45:01: ちなみに昨日の koron-go/materialize もリフレクションないと成立しない。</pre>
<pre>yy_yank 3日 15:46:22: あー、なるほどencoding/json
ORM系も確かにありそうです。
そもそもリフレクションが最終手段感があってそういうところで使われることが多そうですね</pre>
<pre>koron 3日 15:46:47: <https://github.com/koron-go/materialize/blob/cf17f2b04e60328eb42f3ba0691fbce5d812c050/materialize.go#L55></pre>
<pre>koron 3日 15:47:33: 言葉で言うと「ライブラリ成立時に取り扱う型について何の前提も持ち込めない」場合はreflectに頼むしかないんですよね。</pre>
<pre>itchyny 3日 15:47:40: alecthomas/participleとかも</pre>
<pre>koron 3日 15:47:45: いやコード生成があるか。</pre>
<pre>tsuyoshi_cho 3日 15:47:50: 動的にオブジェクト(goならstruct)生成のORMやらのバインディングはリフレクションの添加というか、その視点にたって動く機能ですもんね..</pre>
<pre>itchyny 3日 15:48:12: 任意のstructを受け取っていい感じに値を埋める系</pre>
<pre>mattn 3日 15:48:16: struct tag 弄るならいりますね。</pre>
<pre>mattn 3日 15:48:27: fillin とかも使ってそう。</pre>
<pre>mattn 3日 15:48:53: 使ってなかったw</pre>
<pre>mattn 3日 15:49:28: あ、僕が思ってたやつと違った。</pre>
<pre>itchyny 3日 15:49:33: 文字列なので…</pre>
<pre>mattn 3日 15:50:11: 誰のだったろう。form の validator みたいな奴を見た事あったけど。</pre>
<pre>itchyny 3日 15:50:56: jessevdk/go-flagsとかも</pre>
<pre>mattn 3日 15:51:16: たぶん Perl の HTML::FillInForm と記憶がグチャになってそう。</pre>
<pre>itchyny 3日 15:52:42: リフレクションをうまく使うというよりも、リフレクションせざるを得ないという感じなんですよね</pre>
<pre>itchyny 3日 15:55:35: `reflect` `unsafe` は二大要注意パッケージ</pre>
<pre>johejo 3日 15:58:25: みんGoにもちょっとreflectionの解説がありますね</pre>
<pre>johejo 3日 16:01:07: introduction to black magic in Golang みたいな記事とか本とかないかな</pre>
<pre>mattn 3日 16:02:39: anko はおそらく reflect のほとんどの機能使ってます。</pre>
<pre>mattn 3日 16:03:22: ```#!anko

var http, ioutil = import("net/http"), import("io/ioutil")

r = http.DefaultClient.Get("<http://golang.org/>")
b, _ = ioutil.ReadAll(r[0].Body)
printf("%s", toString(b))
r[0].Body.Close()```</pre>
<pre>raa0121 3日 16:03:26: つまり、anko を読めば reflect マスターになれると</pre>
<pre>mattn 3日 16:03:29: これをスクリプトで動かせる様にしてるので。</pre>
<pre>yy_yank 3日 16:04:30: おぉ、anko楽しいですね
そしてREADMEの団子がうまそう</pre>
<pre>mattn 3日 16:04:44: そんでもって意外と
```#!anko

var http = import("net/http")

http.HandleFunc("/", func(w, r) {
  w.Write(toByteSlice("hello world"))
})
http.ListenAndServe(":8080", nil)```
このウェブサーバが実用できるくらい速い。</pre>
<pre>itchyny 3日 16:05:49: サーバーに埋め込むために機能制限とかできるのかな</pre>
<pre>mattn 3日 16:06:31: import できるパッケージを絞る事はできます。</pre>
<pre>mattn 3日 16:07:01: ガワを生成するコマンドを使えばサードパッケージも import 可。</pre>
<pre>itchyny 3日 16:07:09: よさそう</pre>
<pre>mattn 3日 16:07:36: 幾らかの業務で使って貰ってるらしいですが、誰もどれで使ってるか教えてくれない。</pre>
<pre>vikke 3日 16:07:38: 今僕は雰囲気でGoを書いている。</pre>
<pre>mattn 3日 16:08:41: ちなみに anko から色んな物をそぎ落として、式しか書けないやつが kinako</pre>
<pre>mattn 3日 16:08:48: <https://github.com/mattn/kinako></pre>
<pre>mattn 3日 16:09:14: きなこ餅おいしそう。</pre>
<pre>yy_yank 3日 16:09:17: わらびもちうまそう(そこじゃない)</pre>
<pre>johejo 3日 16:09:34: Goは雰囲気でも割と書ける（個人の主観です</pre>
<pre>yy_yank 3日 16:11:25: ankoはコマンドでscriptをロードで
kinakoはGoコード内で呼び出して引数で式を渡すみたいな感じですかね？</pre>
<pre>mattn 3日 16:13:39: kinako はたしか、どれかの gettext ライブラリの一部に使われてたかな。</pre>
<pre>mattn 3日 16:14:21: VM ぽい事やるには必須になりますね。</pre>
<pre>mattn 3日 16:16:12: <https://github.com/itchyny/gojq/blob/f42ed4671c084d0526f03103e0ce6f13f5915e5f/execute.go></pre>
<pre>mattn 3日 16:16:16: 結構使っていた。</pre>
<pre>johejo 3日 16:16:35: kinako parserとastとvmがイイ感じに読みやすいコード量で実装されてて勉強にちょうど良さそう :sasumatsu:</pre>
<pre>mattn 3日 16:17:28: kinako は読みやすい量かもですね。</pre>
<pre>mattn 3日 16:17:59: slim の go 実装も良く似た感じの量。 <https://github.com/mattn/go-slim/></pre>
<pre>mattn 3日 16:19:56: <http://github.com/alecthomas/participle|github.com/alecthomas/participle></pre>
<pre>mattn 3日 16:20:06: チャラっと VM 書くには便利そう。</pre>
<pre>johejo 3日 16:21:00: チャラい</pre>
<pre>itchyny 3日 16:21:27: participle使い始めるとgoyaccの使い方忘れちゃうんですよ</pre>
<pre>eihigh 3日 16:23:47: participle、いずれがっつりパーサ書くときは使おうと心に決めている。まだその機会はない。</pre>
<pre>ゴリラ 3日 16:44:54: gopls、Macで
GO111MODULES on だと プロジェクト内のパッケージに定義ジャンプできない
auto だと 外部ライブラリに定義ジャンプできない
off だと 問題なし
謎すぎる</pre>
<pre>mattn 3日 16:53:44: GOPATH 内にいます？それとも外です？</pre>
<pre>ゴリラ 3日 16:54:07: 内ですね</pre>
<pre>mattn 3日 17:04:19: 一度 $GOPATH/pkg/mod を別名にするかなんかした方がいいかも。</pre>
<pre>mattn 3日 17:04:45: あとプロジェクト(カレントディレクトリ)直下にある go.mod が正しいかも確認した方がいいかも。</pre>
<pre>mattn 3日 17:05:38: ちなみに特殊な事してないですよね？
* go へのパスがシンボリックリンク
* GOPATH もしくは GOPATH/src/xxx などがシンボリックリンク</pre>
<pre>mattn 3日 17:21:56: 余計なのが混じってるなら tidy するなども。</pre>
<pre>dictav 3日 17:24:20: retag ちょっと使ってます
<https://github.com/sevlyar/retag></pre>
<pre>koron 3日 17:38:23: gopls、ときどきおかしくなるよねw</pre>
<pre>mattn 3日 18:16:34: ゴリラさん、ずっと gopls 動いてないのでたぶんゴリラさんの環境側に何かあるんだと思ってます。</pre>
<pre>mattn 3日 18:17:21: 同じリポジトリで最新の gopls 動かして差が出たので。</pre>
<pre>ゴリラ 3日 18:43:12: &gt; ちなみに特殊な事してないですよね？
&gt; * go へのパスがシンボリックリンク
&gt; * GOPATH もしくは GOPATH/src/xxx などがシンボリックリンク
何もしていないですね</pre>
<pre>ゴリラ 3日 18:43:34: &gt; ゴリラさん、ずっと gopls 動いてないのでたぶんゴリラさんの環境側に何かあるんだと思ってます。
Mac2台ともに同じ現象にあっています…</pre>
<pre>ゴリラ 3日 18:43:53: Linuxは大丈夫だったけど、なぜかMacだけ…</pre>
<pre>ゴリラ 3日 18:44:16: &gt; 余計なのが混じってるなら tidy するなども。
tidy もしました</pre>
<pre>hrsh7th 3日 18:45:08: <@UDDCM376D>
A プロジェクトのファイルを開き、A プロジェクト内で定義ジャンプや補完をする… ①
A プロジェクトのファイルを一度開き、次に B プロジェクトのファイルを別バッファで開いて、B の中で定義ジャンプや補完をする… ②

場合によっては現状の vim-lsp は ② のケースはうまく扱えないかもしれません。</pre>
<pre>ゴリラ 3日 18:45:09: goplsの更新、pkgのclean、Goの更新、プラグインの更新
色々やりました</pre>
<pre>hrsh7th 3日 18:45:17: ① がちゃんと動かないとしたらよくわからないですが。</pre>
<pre>ゴリラ 3日 18:45:44: &gt; ① がちゃんと動かないとしたらよくわからないですが。
①が動かないですね…</pre>
<pre>mattn 3日 18:59:12: 開いた直後はジャンプ効かないですが、すぐ実行しました？</pre>
<pre>ゴリラ 3日 19:19:12: いえ</pre>
<pre>ゴリラ 3日 19:19:22: いくら待ってもジャンプできないですね</pre>
<pre>johejo 3日 19:20:34: これはminimal再現vimrc案件では</pre>
<pre>ゴリラ 3日 19:26:57: ちょっと帰ってミニマムをやってみます</pre>
<pre>daisuzu 3日 20:29:05: ログを見てみると良いかもしれません
GO111MODULEで動きが変わるということはvim-lspよりはgoplsの方が怪しそうです</pre>
<pre>vikke 3日 20:44:25: 型アサーションでデータが欠落する事ってあります?
```    18: func SendMail(script module.Script, opt interface{}) {
    19:         v, _ := opt.(pb.OrderCancelAtShopParam)
=&gt;  20:         log.Printf("SendMail: %s", v.GetScriptName())
    21:
    22:         impl := module.InOutLoggerImpl{}
    23:         <http://impl.In|impl.In>()
    24:         script.Exec(opt)
    25:         impl.Out()
(dlv) p opt
interface {}(*<http://github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam|github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam>) *{
        Id: 1,
        ScriptName: "OrderCancelAtShop",
        XXX_NoUnkeyedLiteral: struct {} {},
        XXX_unrecognized: []uint8 len: 0, cap: 0, nil,
        XXX_sizecache: 0,}
(dlv) p v
<http://github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam|github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam> {
        Id: 0,
        ScriptName: "",
        XXX_NoUnkeyedLiteral: struct {} {},
        XXX_unrecognized: []uint8 len: 0, cap: 0, nil,
        XXX_sizecache: 0,}```
こんな感じで、型アサーションの前後でIdとScriptNameが欠落してしまってます。</pre>
<pre>itchyny 3日 20:47:25: `v, _` となってますが、 `v, ok` として `ok` の値を見てもらえますか</pre>
<pre>itchyny 3日 20:48:52: `ok` が `false` なら型アサーションに失敗しています</pre>
<pre>vikke 3日 20:51:17: ```=&gt;  20:         log.Printf("ok: %s", ok)
    21:         log.Printf("SendMail: %s", v.GetScriptName())
    22:
    23:         impl := module.InOutLoggerImpl{}
    24:         <http://impl.In|impl.In>()
    25:         script.Exec(opt)
(dlv) p ok
false
(dlv) p v
<http://github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam|github.com/lifestyledesign/fabric-tokyo-hermes/idl.OrderCancelAtShopParam> {
        Id: 0,
        ScriptName: "",
        XXX_NoUnkeyedLiteral: struct {} {},
        XXX_unrecognized: []uint8 len: 0, cap: 0, nil,
        XXX_sizecache: 0,}
(```
falseでした。型を思い込んでました。ありがとうございます。</pre>
<pre>itchyny 3日 20:51:44: `opt.(*pb.OrderCancelAtShopParam)` ですね、おそらく。</pre>
<pre>vikke 3日 20:52:20: 確かに。。。面目無い。</pre>
<pre>vikke 3日 20:52:29: ESP力はんぱない。</pre>
<pre>koron 3日 22:34:43: 型アサーションしたあとのOKチェックは必須。</pre>
<pre>koron 3日 22:35:12: 絶対に型があってると思ってもチェックすべし。</pre>
<pre>johejo 3日 23:26:41: terraform-provider-azurermのソースがチェックなし型アサーションだらけでうぇーってなる</pre>
<pre>vikke 3日 23:39:54: 循環参照うぇーーーー。これ直すの大変だなー。というポエム。</pre>
<pre>ゴリラ 4日 11:34:42: sliceのinsert、頭の良さを感じた
<https://github.com/golang/go/wiki/SliceTricks#insert>

``` a = append(a[:i], append([]T{x}, a[i:]...)...)```</pre>
<pre>mattn 4日 11:45:06: なんとなく遅そう。(要検証)</pre>
<pre>mattn 4日 11:48:06: 「Go は任意型の追加とか苦手でしょ」の反論の為に書かれてるものが混じってそう。</pre>
<pre>mattn 4日 15:57:38: <https://twitter.com/mattn_jp/status/1246331001476804609></pre>
<pre>mattn 4日 16:13:29: ちょっと間違っててこそっと直した。</pre>
<pre>itchyny 4日 16:16:27: そこまで変わらんかった…
```/private/tmp go test -bench .
goos: darwin
goarch: amd64
pkg: tmp
BenchmarkAppend-16         97662             11558 ns/op
BenchmarkNormal-16        113486             10220 ns/op```</pre>
<pre>mattn 4日 16:17:12: なんだろう。Windows なんか違うんかな。</pre>
<pre>mattn 4日 16:17:46: あ、StopTimer 入ってない。</pre>
<pre>koron 4日 16:18:26: ん～</pre>
<pre>mattn 4日 16:18:49: なおし。</pre>
<pre>koron 4日 16:18:53: 2つ疑問があって、最初見た時に記事にあったベンチ結果が消えたのと、あとNormalのほうなんでcopyつかわないの?</pre>
<pre>itchyny 4日 16:18:55: ```copy(output, input[:n])
copy(output[n:], insert)
copy(output[n+len(insert):], input[n:])```
これはどうだろう</pre>
<pre>mattn 4日 16:20:14: そもれ良さそう。</pre>
<pre>mattn 4日 16:21:13: ```BenchmarkAppend-8          42700             26185 ns/op
BenchmarkNormal-8          70170             18005 ns/op
BenchmarkCopy-8            90902             15787 ns/op```</pre>
<pre>mattn 4日 16:23:13: 更新した。</pre>
<pre>itchyny 4日 16:24:50: ```BenchmarkAppend-16         99148             12840 ns/op
BenchmarkNormal-16        120246             10274 ns/op
BenchmarkCopy-16          195975              5688 ns/op```</pre>
<pre>mattn 4日 16:25:44: なんの差だろう。</pre>
<pre>mattn 4日 16:26:15: 測り直すたびに変わる。</pre>
<pre>mattn 4日 16:26:19: ```BenchmarkAppend-8          35395             31836 ns/op
BenchmarkNormal-8          61192             21202 ns/op
BenchmarkCopy-8           100820             14641 ns/op```</pre>
<pre>itchyny 4日 16:26:49: いずれにせよ みんな copy 使おう</pre>
<pre>tsuyoshi_cho 4日 16:26:57: キャッシュメモリとかが響く?</pre>
<pre>mattn 4日 16:26:57: そうね。</pre>
<pre>tsuyoshi_cho 4日 16:27:10: まあcopyですよね...</pre>
<pre>mattn 4日 16:28:37: copy は気を付けないと突き抜けるケースがあるので少しアレ。</pre>
<pre>mattn 4日 16:29:10: len 以上、cap 以下にコピーしうるケース。</pre>
<pre>tsuyoshi_cho 4日 16:29:34: unmanageな機能ってところですか</pre>
<pre>mattn 4日 16:29:56: コアチームも稀にやってしまう。</pre>
<pre>eihigh 4日 16:31:09: insertはループ回してやるかなあ、sliceTrickでも書けるんですけどやっぱ読みづらいし…</pre>
<pre>eihigh 4日 16:31:45: unshiftくらいまでならappendでやるけど。</pre>
<pre>mattn 4日 16:32:16: 少なくとも cap がデカくなる append のハックは無いすね。</pre>
<pre>tsuyoshi_cho 4日 16:35:05: insertが頻発する場合は、array-link-listなやつを作っちゃって、ですかねえ</pre>
<pre>mattn 4日 16:37:55: 動的型付け言語触る人達は Go の配列やスライスがメモリブロックだって意識が少し薄いかもしれない。</pre>
<pre>ゴリラ 4日 17:58:08: ベンチマークあざます
勉強になりました</pre>
<pre>eihigh 4日 18:06:27: &gt; メモリブロックだって意識が少し薄いかも

すごく健康的だ……[][]を見ただけでメモリ配列が気になって夜も眠れなくなるので……</pre>
<pre>mattn 4日 18:17:35: C言語やってる人だと配列が2次元にも3次元にも見えるので便利。</pre>
<pre>tsuyoshi_cho 4日 18:18:41: 逆に最終的なフラットなメモリ空間を想像して齟齬がでたりしてw</pre>
<pre>ゴリラ 4日 18:42:28: &gt; 動的型付け言語触る人達は Go の配列やスライスがメモリブロックだって意識が少し薄いかもしれない。
メモリブロック…？</pre>
<pre>mattn 4日 21:46:24: 例えば Ruby だと `a = [1, 2, 3]` ってやったら数値が3つで 8 バイト x 3 = 24 バイト取ってそうに見えるけど、実際は型の情報も持ってるし `a[1] = "foo"` ってやったらオブジェクトもリンクされる。つまりメモリが直列じゃないんですよね。Go だと `[500]byte` は 500 バイトなんですよね。1要素に 1 バイト以上の物は突っ込めない。</pre>
<pre>vikke 5日 17:01:53: interfaceと実装は同じpackageじゃないと駄目。覚えた。</pre>
<pre>tennashi 5日 17:12:26: そんなことはないですよ
<https://golang.org/pkg/io/#Reader>
<https://golang.org/pkg/bytes/#Buffer.Read></pre>
<pre>vikke 5日 17:19:12: あれ? さっき書いてて、同じパッケージにしてねってメッセージが出たんだが。幻?</pre>
<pre>iwata 5日 17:23:25: unexportedだったとか？</pre>
<pre>vikke 5日 17:25:26: <https://qiita.com/Yarimizu14/items/e93097c4f4cfd5468259> な話?</pre>
<pre>kyoh86 5日 21:16:02: Linuxbrewが思うように動かなくて怒りのあまり作ってしまった</pre>
<pre>kyoh86 5日 21:16:03: <https://qiita.com/kyoh86/items/f5e007bc004c34b2d314></pre>
<pre>kuu 5日 21:17:15: 怒り駆動開発わかる</pre>
<pre>kyoh86 5日 21:20:19: 多分同じ時間使えばlinuxbrew動いたんですけどね</pre>
<pre>kyoh86 5日 21:20:41: こうしてまた訳のわからんオレオレツールが爆誕するのだ</pre>
<pre>tsuyoshi_cho 5日 22:11:30: good</pre>
<pre>tsuyoshi_cho 5日 22:11:51: しかしlinuxbrewがうまくいかないと、どうしました?</pre>
<pre>mattn 5日 22:13:06: 僕はこういうツールの名前自体を忘れてしまう。</pre>
<pre>kyoh86 5日 22:30:09: なんかいい名前がアレば変えようと思ってます笑</pre>
<pre>kyoh86 5日 22:30:26: godownloaderとかghgとか取られちゃってるんで、どうすっかなーという気持ち</pre>
<pre>tsuyoshi_cho 5日 22:32:09: 5getter (いま5chだから) はあれですね...</pre>
<pre>kyoh86 5日 22:33:56: そういや不思議と数字から始めるコマンドって発想がなかったですね…なるほど</pre>
<pre>thinca 5日 22:35:16: 2to3</pre>
<pre>kuu 5日 22:36:04: 7z</pre>
<pre>kyoh86 5日 22:44:20: たしかに</pre>
<pre>kuu 5日 22:46:10: babelも昔は数字ネームだったような</pre>
<pre>kyoh86 5日 22:47:11: ちなみにlinuxbrewが動かなかったのは、インストールの段階でrubyの何かのエラーが出た瞬間、僕のrubyトラウマ的事情で深堀りを諦めてしまっただけです</pre>
<pre>tsuyoshi_cho 5日 22:47:37: 手動インストールしたほうがよかったかもですね</pre>
<pre>tsuyoshi_cho 5日 22:48:23: あー、でも今はbashインストーラだから、その後の段階かもしれないですし、ちょっと面倒ですね</pre>
<pre>eihigh 5日 22:48:38: Goも昔は数字ネーム。</pre>
<pre>eihigh 5日 22:49:33: &gt; 今はbashインストーラ
いったい何nyさんの偉業なんだ…</pre>
<pre>mattn 5日 23:48:25: <https://twitter.com/mattn_jp/status/1246801704634306563></pre>
<pre>mattn 5日 23:48:49: 何ny さんが欲しいって言ってたやつ。</pre>
<pre>raa0121 6日 00:33:41: <https://gobinaries.com/></pre>
<pre>raa0121 6日 00:34:13: curl と sh だけあれば動くやつ</pre>
<pre>Hajime Hoshi 6日 01:03:07: 最近 go install しないでなるべく go.mod 有効範囲内で go run している</pre>
<pre>kyoh86 6日 07:33:21: gobinaries便利そうですよねー。
go向きじゃないツールの案内にはいい</pre>
<pre>mattn 6日 07:43:16: tj 氏、昔から有名人なのでまぁ大丈夫と思うけど僕はこういうの「知らない人からお菓子貰っちゃいけません」みたいな自制力が働く。</pre>
<pre>tsuyoshi_cho 6日 08:41:52: とはいえ、特にCIなら、都度コンンパイルよりはプリビルドバイナリだよな、というのもなきにしもあらず..</pre>
<pre>johejo 6日 10:15:25: パイプでshに流し込むやつ 基本的にいつも中身をチェックしてる。
CI上でもteeとかでstderrなんかにも流すようにしたりset -xとかしたほうがいいのかな。</pre>
<pre>itchyny 6日 13:11:29: <#CGZTGR6E6|javascript> でASI (automatic semicolon insertion) が話題になっているけれど、Go言語も実はASIは行われている (JavaScriptと違ってむしろセミコロン省略が推奨される)。<https://golang.org/ref/spec#Blocks> を見ると `StatementList = { Statement ";" } .` となっており、ここに改行がセパレーターとして使えるという記述はない。セミコロン挿入のルールは <https://golang.org/ref/spec#Semicolons> 。このルールが頭に入っていると以下のようなコードがなぜコンパイルできないのかが理解できる (そしてJavaScriptのASIルールとの違いも感じられる)。
```x := "x"
	+ "y"
switch strings.ToUpper(x)
{
	case "XY":
		println(x)
}```</pre>
<pre>tyru 6日 13:52:17: gofmt するとこうなった。なるほど
```	x := "x"
	+"y"
	switch strings.ToUpper(x); {
	case "XY":
		println(x)
	}```</pre>
<pre>tyru 6日 13:52:58: 基本的に :w 時に gofmt かけるようにしてるので知らなかった</pre>
<pre>johejo 6日 17:20:40: retryableなhttp clientでよく使われているのって
- hashicorp/go-retryablehttp
- gojektech/heimdall
とかですかね。
自前で実装してもいいけどエラーハンドリングとbodyのio.Readerのところちょっと工夫しないといけなさそうなで参考になりそうな実装を探してます。</pre>
<pre>dohq 6日 17:53:57: <https://github.com/cenkalti/backoff>
もなんかで見た記憶ありますね</pre>
<pre>mattn 6日 18:02:25: <https://github.com/shogo82148/go-retry></pre>
<pre>mattn 6日 18:02:54: <https://github.com/Songmu/retry></pre>
<pre>mattn 6日 18:02:59: クライアントではないけど。</pre>
<pre>mattn 6日 18:15:11: もひとつ
<https://github.com/lestrrat-go/backoff></pre>
<pre>tsuyoshi_cho 6日 18:15:50: リポジトリでわかるとはいえ、かぶりまくり</pre>
<pre>mattn 6日 18:17:36: 現存システムに近い作りになってるでしょうし、少しずつ違うんでしょうな。</pre>
<pre>mattn 6日 18:18:35: <https://twitter.com/xatierlikeLee/status/1247069907813937160></pre>
<pre> 6日 18:18:50: </pre>
<pre>mattn 6日 18:18:52: ぜんぜんかわらない...</pre>
<pre>dohq 6日 18:19:05: どういうことなの…</pre>
<pre> 6日 18:21:21: ぜんぜんわからない</pre>
<pre>mattn 6日 18:25:49: アカウント名、日本語だし聞いてみるのもいいかも。</pre>
<pre> 6日 18:27:00: </pre>
<pre>raa0121 6日 18:27:10: excite もわからん…</pre>
<pre>mattn 6日 18:28:06: これ、deepl の訳とか信じてしまうと下手すると事故るでw</pre>
<pre>raa0121 6日 18:29:18: ops → oppai …？</pre>
<pre>mattn 6日 18:30:30: 中国語は一度英語に変換してから日本語に変換するとうまく行く、という話を昔聞いた事があるのでやってみました。</pre>
<pre> 6日 18:30:33: </pre>
<pre>mattn 6日 18:30:38: 中国語なにも分からない</pre>
<pre>mattn 6日 18:34:48: 聞いた。</pre>
<pre>itchyny 6日 18:39:40: 出來 (chūlái) → 粗乃 (cūnǎi) なのかな？</pre>
<pre>thinca 6日 18:45:40: 中国語分かる ~人~ ゴリラに翻訳してもらうとよさそう <@UDDCM376D></pre>
<pre>itchyny 6日 18:46:27: (((プロフ見たところ単に好きなだけな気もする)))</pre>
<pre>mattn 6日 18:47:44: えっ。質問してしまった。そういう返事が返ってきた時にどう返せばいいの...</pre>
<pre>thinca 6日 18:48:18: 日本にもこういう人いるからなぁ。そういう可能性ありそう</pre>
<pre>mattn 6日 18:49:09: つらい</pre>
<pre>ゴリラ 6日 18:58:53: mattnさん、中国でも神様認定されてるのか</pre>
<pre>johejo 6日 19:34:46: お、いろいろ紹介していただいてありがとうございます</pre>
<pre>mattn 6日 20:52:56: <https://twitter.com/xatierlikeLee/status/1247125215802322944?s=20|https://twitter.com/xatierlikeLee/status/1247125215802322944?s=20></pre>
<pre>mattn 6日 20:53:06: 中国語ぜんぜん分からない。</pre>
<pre>ゴリラ 6日 21:15:45: ぼくも全然分からない</pre>
<pre>ゴリラ 6日 23:38:48: もっとGoに詳しくなりたい</pre>
<pre>ゴリラ 6日 23:38:57: もっとGo書けるようになりたい</pre>
<pre>ゴリラ 6日 23:39:09: そんな想いが溢れる深夜23時</pre>
<pre>ゴリラ 7日 01:00:49: Pratt、少し仲良くなれた気がした</pre>
<pre>ゴリラ 7日 01:01:21: パーサのとこ、理解しつつある</pre>
<pre>ゴリラ 7日 01:01:34: 少しだけ成長した気がした</pre>
<pre>mattn 7日 07:58:37: :goodpoem:</pre>
<pre>ゴリラ 7日 08:57:38: パーサの動き、少しずつわかってきたけど、どうその実装に至ったのか、まだ良くわかっていない</pre>
<pre>ゴリラ 7日 08:57:57: そこさえ理解できれば、応用ができるようになるはず</pre>
<pre>ゴリラ 7日 09:06:02: <http://logic.cs.tsukuba.ac.jp/ppl2016/slides/visual_parsing.pdf|http://logic.cs.tsukuba.ac.jp/ppl2016/slides/visual_parsing.pdf></pre>
<pre>kuu 7日 09:10:11: とてもいい資料だ</pre>
<pre>mattn 7日 09:22:55: ね、いい資料。</pre>
<pre>ゴリラ 7日 09:26:28: ぼくにはまだ難しい</pre>
<pre>ゴリラ 7日 09:26:58: Prattのところな、イメージはできました</pre>
<pre>johejo 7日 09:45:09: 大学でこの手の単位ちゃんと取ったはずなのに何も覚えてない....</pre>
<pre>mattn 7日 09:47:32: その辺を学ぶの、言語を作るがゴールなのであれば若干遠回りな感じもする。</pre>
<pre>mattn 7日 09:47:58: いっそ BNF 学んで感触つかむってのもいいかも。(ここは意見が割れるかも)</pre>
<pre>mattn 7日 09:52:23: その辺行けたらたぶん vimlparser にコントリビュートできますね。</pre>
<pre>koron 7日 10:19:41: これめちゃくちゃ良い資料だな…</pre>
<pre>koron 7日 10:20:16: ただ初学者には図の意味からしてわからんから、解説必須な感じ。</pre>
<pre>ゴリラ 7日 10:24:05: &gt; いっそ BNF 学んで感触つかむってのもいいかも。(ここは意見が割れるかも)
BNFはなんとなく読めるくらいですね
それをコードに落とし込むってところが全然まだまだですね…</pre>
<pre>mattn 7日 11:40:59: そういえば↑の tj が更改してる Go のバイナリを作ってくれる奴、CPU 依存な奴はどうなるんだろう。</pre>
<pre>itchyny 7日 16:45:35: <https://github.com/golang/go/issues/38287> なんだろう？</pre>
<pre>mattn 7日 17:11:24: ほえー。go1.13 から go1.14 にそんな変更がみあたらん。</pre>
<pre>mattn 7日 17:11:51: overwrite の場合に限った話ぽいけど。</pre>
<pre>mattn 7日 17:29:37: ん？ `MoveFileEx(from, to, MOVEFILE_REPLACE_EXISTING)` が RO の時に false 返るんやけど。</pre>
<pre>mattn 7日 17:30:06: これもしかして以前は `chmod +w` みたいな事してたんとちゃうか。</pre>
<pre>koron 7日 17:31:14: 古いのすぐ見れるけど、どこみればええの?</pre>
<pre>mattn 7日 17:33:48: os.Remove の呼び出しから先は見たので ioutil.WriteFile の perm がちゃんと使われていたかどうか、くらいかなぁ。</pre>
<pre>mattn 7日 17:34:07: あ、いや。</pre>
<pre>mattn 7日 17:34:25: まずは</pre>
<pre>koron 7日 17:34:38: まったくおなじだったわ</pre>
<pre>mattn 7日 17:34:51: ```package main_test

import (
        "io/ioutil"
        "os"
        "testing"
)

func TestRenameRO(t *testing.T) {
        os.Remove("a")
        os.Remove("b")
        defer os.Remove("a")
        defer os.Remove("b")

        if err := ioutil.WriteFile("a", []byte("some data"), 0644); err != nil { // rw
                t.Fatal(err)
        }
        if err := ioutil.WriteFile("b", []byte("some data"), 0444); err != nil { // ro
                t.Fatal(err)
        }
        if err := os.Rename("a", "b"); err != nil {
                t.Error(err)
        }
}```</pre>
<pre>mattn 7日 17:35:00: これ go1.13 で通りますか？</pre>
<pre>mattn 7日 17:36:37: ioutil.WriteFile が perm ちゃんと設定できてなかった、みたいな方が濃厚な気もするけど。</pre>
<pre>koron 7日 17:36:59: 通るわw</pre>
<pre>mattn 7日 17:37:21: まじかー</pre>
<pre>koron 7日 17:37:36: でねdefer消すとbだけ残る</pre>
<pre>mattn 7日 17:37:42: ほう。</pre>
<pre>koron 7日 17:37:50: 1.14にしてやってみるね</pre>
<pre>koron 7日 17:39:12: 1.14.1 だと a, b両方残って b はreadonlyっぽい</pre>
<pre>mattn 7日 17:40:05: Go まったく使わず C言語で
```touch a b
chmod -w b```
(これは msys2 で)
して
```#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

int
main() {
  printf("%d\n", MoveFileExW(L"a", L"b", MOVEFILE_REPLACE_EXISTING));
  printf("%d\n", GetLastError());
  return 0;
}```
実行したら 0 2 なんす。</pre>
<pre>mattn 7日 17:40:21: なので今の Go の動きは書いてある通りに動いてる。</pre>
<pre>koron 7日 17:40:38: ふむ。やっぱ 1.13.9 だと、b が書き込み可能で残ってる。</pre>
<pre>koron 7日 17:40:56: ioutil.WriteFileのpermがちゃんと動いてなかった説濃厚</pre>
<pre>mattn 7日 17:40:57: 書き込み可能な a が b にリネームされたからかと。</pre>
<pre>mattn 7日 17:41:15: つまりそういう事ですかね &gt; 濃厚</pre>
<pre>mattn 7日 17:41:32: Rename も defer も消したら両方残るんじゃないすかね。</pre>
<pre>mattn 7日 17:41:41: でそのファイルモードが見たいす。</pre>
<pre>mattn 7日 17:41:47: go1.13 の。</pre>
<pre>koron 7日 17:42:01: えっと両方とも書き込み可能で作成されてたわ。</pre>
<pre>koron 7日 17:42:06: スクショ要る?</pre>
<pre>mattn 7日 17:42:20: あ、やっぱり WriteFile が失敗してたって話か。</pre>
<pre>koron 7日 17:42:28: ええ。</pre>
<pre>koron 7日 17:42:39: っていうか書き込み不可だと、os.Removeは失敗しますのう。</pre>
<pre>koron 7日 17:47:26: あれ? 1.13.9 の syscall/syscall_windows.go の Open が perm 使ってないよ?w</pre>
<pre>koron 7日 17:48:03: `h, e := CreateFile(pathp, access, sharemode, sa, createmode, FILE_ATTRIBUTE_NORMAL, 0)` こうなってるw</pre>
<pre> 7日 17:48:24: 一方で1.14.1 はこう</pre>
<pre>koron 7日 17:48:33: これはワロスw</pre>
<pre>mattn 7日 17:50:32: <https://github.com/golang/go/commit/16f0f9c8e1e767d10d483939981e3b2242554c33></pre>
<pre>mattn 7日 17:50:36: これっぽい気がする。</pre>
<pre>mattn 7日 17:51:29: side effect だなこれ。</pre>
<pre>mattn 7日 17:52:35: コミットメッセージに悪かったのが直ったって書いてあるしな。</pre>
<pre>koron 7日 17:53:41: それですなw</pre>
<pre>koron 7日 17:54:07: 問題があるとすると os.Remove() がREADONLYファイルに失敗することかも。</pre>
<pre>mattn 7日 17:54:33: それはそれでなんかあった気がする。</pre>
<pre>mattn 7日 17:56:35: あ、あってたわ。</pre>
<pre>mattn 7日 17:56:36: <https://github.com/golang/go/issues/26295></pre>
<pre>mattn 7日 17:57:01: Windows の DeleteFile って readonly だとエラーになるんですよね。</pre>
<pre>mattn 7日 17:57:36: <https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-deletefilea>
&gt; To delete a read-only file, first you must remove the read-only attribute.</pre>
<pre>mattn 7日 17:57:47: ひどい仕様です。</pre>
<pre>mattn 7日 17:58:35: ディレクトリを一括で消してる最中に別の要因で消せなくなった際に元に戻せないなら 26295 はマージすべきじゃない、みたいな話だったと思う。</pre>
<pre>koron 7日 17:59:44: エクスプローラーからだと消せるんだけど…shell32.dllが頑張ってんのか…</pre>
<pre>mattn 7日 18:01:39: 現状 Windows でも同じ様にちゃんと RO になる可能性のあるファイルを消すなら os.Chmod で +w してから os.Remove しないといけないって話になってしまう。</pre>
<pre>koron 7日 18:03:15: OSの差異だから、os.Removeの仕様としてやってくれると助かるのは助かりますねぇ。</pre>
<pre>mattn 7日 18:03:40: そうすね。</pre>
<pre>tsuyoshi_cho 7日 18:04:17: ちなみにですが、逆にUnixだとディレクトリのパーミッションチェックとかどうなんでしょう?</pre>
<pre>koron 7日 18:04:21: 事前にチェックしてないなら、やってみてエラー見てos.Chmod(+w)ケースかな</pre>
<pre>mattn 7日 18:10:22: いややっとるな。</pre>
<pre>mattn 7日 18:10:41: <https://github.com/mattn/go/blob/2fbca94db7e14fc1d18162cd203d7afc19b520e8/src/os/file_windows.go#L302></pre>
<pre>mattn 7日 18:10:59: これが機能しとらん。(僕のアイコン出てきてビビった時の顔)</pre>
<pre>mattn 7日 18:11:28: この条件が ATTRIBUTE_NORMAL でもやらんといかん。</pre>
<pre>k-takata 7日 18:40:16: ディレクトリの場合にはREADONLYビットを落としてリトライはしないのかな？</pre>
<pre>mattn 7日 18:41:11: ディレクトリの場合は RemoveDirectory 使ってるんですよね。</pre>
<pre>mattn 7日 18:41:49: そっちはたしか ro を消せた気が。</pre>
<pre>mattn 7日 18:43:00: いや、このコードは中のファイルが ro の可能性あるから「無理だって」話かな。</pre>
<pre>mattn 7日 18:44:24: 一応 CL 投げた。</pre>
<pre>mattn 7日 18:47:41: 前々関係ないけど「プログラミング言語大全」の献本が飛んでくる事になった。</pre>
<pre>mattn 7日 18:48:11: ﾀﾀﾞ読みｻｲｺｰ</pre>
<pre>k-takata 7日 18:54:32: RemoveDirectoryもro消せなかったような。</pre>
<pre>k-takata 7日 18:57:57: しかし、Unix系はファイル・ディレクトリ自身ではなく、それがあるディレクトリがroだと消せないという動きだから、動作が違ってややこしい。</pre>
<pre>mattn 7日 20:11:13: ですね。</pre>
<pre>tsuyoshi_cho 7日 21:26:10: ですねえ
そしてもしかして誤解されてるかもですが、「Unix系のファイル削除で、その親のディレクトリのパーミッション不足の時の動作はどうなんだろう」だったんです...とはいえたぶん考慮されてるかな?</pre>
<pre>mattn 7日 21:27:47: Windows の場合はどちみちディレクトリじゃなくファイルの権限変えていかないと消せないし、その途中でエラーが発生する可能性もあるので、そうなると元に戻すの大変なんすよね。</pre>
<pre>tsuyoshi_cho 7日 21:31:50: たしかに</pre>
{% endraw %}
